I have been having problems with the two python applications, used for bitcoin (btcusd trade pair) auto trading. These are listed and described below. Their main files are src/bktst.py and src/tdr.py and each have other local dependencies under the src directory.

The src/bktst.py application, listed first, is a back tester and 'src/tdr.py', the second one, is an interactive command line driven program used to perform and allow the user to check on the status of auto trades based on either one of two different strategies identified using the back tester.  The information over which strategy and tuned parameters to use is created by bktst, and stored in a file called best_strategy.json. 

I had reached a level of moderate stability and quality when src/tdr.py only supported a moving average crossover strategy. The following is the contents of my best_strategy.json file that I am currently running this older version and performing live trading on:


{
    "Frequency": "1H",
    "Strategy": "MA",
    "Short_Window": 4,
    "Long_Window": 38,
    "Final_Balance": 10499.328525204743,
    "Total_Return": 4.993285252047426,
    "Total_Trades": 47.0,
    "Average_Trades_Per_Day": 1.5666666666666667,
    "Profit_Factor": 1.055339869790974,
    "Sharpe_Ratio": 0.2711064084592064,
    "Last_Signal_Timestamp": 1736722800,
    "Last_Signal_Action": "GO SHORT",
    "Last_Trade_Timestamp": 1736723593,
    "Last_Trade_Price": 94166.0,
    "do_live_trades": true
}



Unfortunately I fear the quality diminished when I inntroduce the RSI strategy.  Thus one of the items I would like you to focus on is refining the logic and features to be more shared between the MA and the RSI modes.

Here is an example that I am testing with. It so happens we have both a dry-run and live mode, and so I am stuck in dry-run mode getting this to work with RSI.

{
    "Strategy": "RSI",
    "RSI_Window": 12,
    "Overbought": 75,
    "Oversold": 30,
    "Final_Balance": 10730.391578353923,
    "Total_Return": 7.303915783539232,
    "Total_Trades": 112.0,
    "Average_Trades_Per_Day": 3.6129032258064515,
    "Profit_Factor": 1.2233172141355977,
    "Sharpe_Ratio": 0.5502781564574327,
    "Last_Signal_Timestamp": 1739314800,
    "Last_Signal_Action": "GO LONG",
    "Last_Trade_Timestamp": 1739395492,
    "Last_Trade_Price": 97561.0,
    "do_live_trades": false
}



There is a web socket application not shown here called src/websock-ticker2.py that is constantly running and collecting real time price / trade data and storing it into the file named btcusd.log.  It so happens that btcusd is the crypto pair I am trading. This file is used by bktst.py. The trading time granularity is coarser than is tdr.py however the idea is to use the strategy that showed good performance historically and it is hoped will inform live trading choices.  

Now it is the auto_trade feature that I am having several issues with and I hope you can check the code to locate these bugs.   First of all it is very important that you understand how the auto_trade command is supposed to work because I believe my assistant may have misunderstood.

The user will start auto trading by first looking at their account in bitstamp to see if they are long or short btcusd and based on that they will come up with an amount they are long or short.  Now here are some important considerations:

At any given time, for example just prior to starting the auto_trade, they are either 100% in usd or 100% in btc.  If they are in usd that means that they are short the btcusd trading pair, if they are in btc it means they are long the btcusd trading pair.

The user enters the auto_trade command at the src/tdr.py prompt using this form:  auto_trade <amount><currency> <direction>

The <amount> value is a floating point term. e.g. 995.75, 2, 2.05, etc...
The <currency> value is either btc or usd for bitcoin or us dollar.
The <direction> value is either long or short.

If the <currency> value is usd, then the direction MUST be short.
If the <currency> value is btc, then the direciton MUST be long.

This means that the <direction> can be computed from the <currency> value however it is required to reduce error and allow for a valdity check.

If either of these <currency> <direction> rules are violated, tdr should report an error and do nothing.

The auto_trade command needs to be interpeted as "I would like you to start performing auto_trades using my current count controlling the entire balance here which is in the form of <currency> in the amount of <amount> and this represents a <direction> position in btcusd."


It is the job of src/tdr.ty at this point to assess the current market conditions with respect to the trading strategy defined in the best_strategy.json file along with the historic data stored in btcusd.log (which is constantly being updated) and see if there is a MATCH between the <direction> (as included in the auto_trade command) and the "current direction" as computed by observing the btcusd.log data.  

Again, this data is tick by tick data so we are intereted in a fine grained version of that trading status.

If there is a MATCH between what the user said their position status was using the auto_trade command, then the src/tdr.py has no immediate trade to do, but MUST record the position as though the balance described was just obtained via a trade.  We shall call the market price of btcusd at the time of the auto_trade command the 'theoretical entry price and the amount given by the user as the balance.  At all times the status should report the last entry price, position and current price and value of the position both in USD and in BTC as well as what direction (long or short) their position is with respect to the btcusd trading pair.

If there is a MISMATCH between what the user said their position status was using the auto_trade command, then the src/tdr.py then src/tdr.py must perform an auto trade. It so happens that if such a trade involves going long, then the trade must be performed in 3 partial trades, each being 90% of the remaining balance.  This is because bitstamp puts a limit of 90% and since our goal is to trade 100% this approximately gets us there.  HOWEVER, this should be regarded as a single trade towards the global limit on trades per day.



Let's go through some examples:

1. User is short btcusd and strategy signal indicates short.

Let's say the user is short, which means they hold usd.  Let's say there are short $10000usd. This means that when they invoke the auto_trade command they would say:

auto_trade 10000usd short

now when this command is issued the system needs to decide by looking at data collected from btcusd.log whether the strategy indicated by best_strategy.json is signaling a long or a short position in btcusd.   IF there is a match, which in this case means a signal of short is indicated then there is no trade to make and the system should reflect a theoritical open price at the market level and the amount given. We should always maintain a USD and BTC equivlaent based on the current market price and this is the data that should be reflected by the tdr status command.  Please note that this status command was working quite well when we had the MA only auto trade however the status has never worked well for the RSI strategy and may have even broken since we added it. 


2. User is short btcusd and strategy signal indicates long.

In this case the auto tradng system must change the existing positon from short to long.  Since the user indicated they are short 10000usd they will use that amount of USD to buy btcusd at the market price. It so happens that bitstamp has a rule about only allowing 90% of their balance to be used on any single trade so the code will execute 3 trades (known as partial trades) in order to use the 10000usd to go into a long posiion.  Now it is here where I have seen a bug because we have a limit 


3. User is long btcusd and strategy signal indicates long.

auto_trade 2.5btc long

This should be treated just like the case 1. above where user is short btcusd and strategy signal indicates short. Since the user declared trade direction matches the strategy indicated direction, there is nothing to do other than record a theoretical entry price matching the market price and the amount indicated.

4. User is long btcusd and strategy signal indicates short.

In this case the auto tradng system must change the existing positon from long to short.  Since the user indicated they are long 2.5btc they must sell 2.5 btcusd at the current market price.  Bitstamp imposes no restrictions here regarding total amounts, so it is perfectly okay to sell all 2.5btcusd in one trade.

Trade Limit. There is a bug in that the current trade limit is 3 per day. Please set the trade limit to 5 trades per day, but fix the bug so that the 3 partial trades needed to go LONG are counted as only ONE trade towards this limit. There is a known bug that the 3 partial trades are each being counted and so this leads to hitting our limit far too fast.

Status.  There are several problems with the status command for RSI especially.

Here is an example when in MA auto trade mode:

(crypto) status

Position Details (Short View):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  • Direction: Long
  • Current Price:  $98139.00
  • Entry Price:    $0.00
  • Position Size (BTC): 0.00000000
  • Position Value (USD): $0.00
  • Unrealized PnL:  $0.00

  • MA Crossover Proximity: 1.60%
    (Closer to 0% means closer to flipping from short->long or long->short)


Entry Price: should never be $0.00.  It should always record the market price of a theoretical position, if the auto_trade direction matches what the strategy says, or it should report the price for the actual last trade that was made.  In case that multiple partial trades this should be the average price of those trades.  But never 0.00.

The position size should be the theoritical amount given in the auto_trade command if the directions match and it should be the total amount traded to flip the position if that was what happened. Again if there were 3 partial trades this should be the sum of those amounts.

KNOWN bugs
1. status reports zero for position values when it should computed them as per the last trade or theoretical trade.
2. TRADES per day limit should be 5 not 3.
3. When 3 partial trades are performed to go long (as described above) the system incorrectly counts this as 3 trades towards the day limit--- we must have tdr.py count the entire set of partial trades as just one trade agaist the dailly limit.
4. Proximity value is not being reported for the RSI mode.


Things to confirm:
1. That status works correctly and display the current direction, value and positions and proximity for the current strategy and what that strategy is.
2. Sufficient data is collected in dry-run and live mode, into a JSON file so that we may have a programi, being worked on, called src/trade-checker.py verify by reading btcusd.log and best_strategy.json that the correct trades were identified and that none were missed nor performed when the signal did not indicate a signal.
3. No features are not fully supported by both MA and RSI, with efficient use of code sharing.

Here is the src/bktst.py app and dependencies:
./src
├── backtesting
│   ├── __init__.py
│   └── backtester.py
├── bktst.py
├── data
│   ├── __init__.py
│   └── loader.py
├── indicators
│   ├── __init__.py
│   └── technical_indicators.py
├── optimization
│   ├── __init__.py
│   └── optimizer.py
├── strategies
│   ├── __init__.py
│   └── ramm_strategy.py
└── utils
    ├── __init__.py
    ├── analysis.py
    └── helpers.py

--- BEGIN FILE: backtesting/__init__.py ---
# src/backtesting/__init__.py

--- END FILE: backtesting/__init__.py ---

--- BEGIN FILE: backtesting/backtester.py ---
# src/backtesting/backtester.py

import pandas as pd
import numpy as np

from indicators.technical_indicators import ensure_datetime_index

def backtest(df, strategy, initial_balance=10000, position_size=0.1, transaction_cost=0.001, max_trades_per_day=10):
    df = ensure_datetime_index(df)
    df['Position'] = df[f'{strategy}_Signal'].shift(1).fillna(0)
    df['Returns'] = df['price'].pct_change().fillna(0)
    df['Strategy_Returns'] = df['Position'] * df['Returns']

    # Calculate transaction costs
    df['Trade'] = df['Position'].diff().abs()
    df['Transaction_Costs'] = df['Trade'] * transaction_cost

    # Limit trades per day
    df['Daily_Trades'] = df['Trade'].groupby(df.index.date).cumsum()
    df.loc[df['Daily_Trades'] > max_trades_per_day, 'Strategy_Returns'] = 0

    df['Strategy_Returns'] -= df['Transaction_Costs']
    df['Cumulative_Returns'] = (1 + df['Strategy_Returns']).cumprod()
    df['Balance'] = initial_balance * df['Cumulative_Returns']

    total_trades = df['Trade'].sum()

    # Calculate average trades per day
    from datetime import timedelta
    trading_days = (df.index[-1].date() - df.index[0].date()).days + 1
    average_trades_per_day = total_trades / trading_days if trading_days > 0 else 0

    # Profit factor and Sharpe ratio
    positive_returns = df.loc[df['Strategy_Returns'] > 0, 'Strategy_Returns'].sum()
    negative_returns = -df.loc[df['Strategy_Returns'] < 0, 'Strategy_Returns'].sum()
    profit_factor = positive_returns / negative_returns if negative_returns != 0 else np.inf

    sharpe_ratio = (df['Strategy_Returns'].mean() / df['Strategy_Returns'].std()) * np.sqrt(252) if df['Strategy_Returns'].std() != 0 else 0

    final_balance = df['Balance'].iloc[-1]
    total_return = (final_balance - initial_balance) / initial_balance * 100

    return {
        'Final_Balance': final_balance,
        'Total_Return': total_return,
        'Total_Trades': total_trades,
        'Average_Trades_Per_Day': average_trades_per_day,
        'Profit_Factor': profit_factor,
        'Sharpe_Ratio': sharpe_ratio
    }

def generate_trade_list(df, strategy):
    """
    Generate a list of all trades (long AND short) for the given strategy.

    Original logic only tracked long entries (signal==1) and exits (signal==-1),
    ignoring short trades. We have now expanded this to handle short entries and
    exits as well.

    The trades list will contain a dictionary for each completed trade:
    {
        'Entry Time': ...,
        'Exit Time': ...,
        'Entry Price': ...,
        'Exit Price': ...,
        'Profit (%)': ...
    }
    """
    trades = []
    position = 0
    entry_price = 0
    entry_time = None

    for index, row in df.iterrows():
        signal = row.get(f'{strategy}_Signal', 0)

        # ----------------------------
        # LONG ENTRY
        # ----------------------------
        if signal == 1 and position == 0:
            position = 1
            entry_price = row['price']
            entry_time = index
        
        # ----------------------------
        # LONG EXIT
        # ----------------------------
        elif signal == -1 and position == 1:
            exit_price = row['price']
            profit = (exit_price - entry_price) / entry_price
            trades.append({
                'Entry Time': entry_time,
                'Exit Time': index,
                'Entry Price': entry_price,
                'Exit Price': exit_price,
                'Profit (%)': profit * 100
            })
            position = 0

        # ----------------------------
        # SHORT ENTRY (ADDED)
        # ----------------------------
        elif signal == -1 and position == 0:
            # ADDED: logic for opening a short
            position = -1
            entry_price = row['price']
            entry_time = index

        # ----------------------------
        # SHORT EXIT (ADDED)
        # ----------------------------
        elif signal == 1 and position == -1:
            # ADDED: logic for closing a short
            exit_price = row['price']
            # profit for short is (Entry Price - Exit Price) / Entry Price
            profit = (entry_price - exit_price) / entry_price
            trades.append({
                'Entry Time': entry_time,
                'Exit Time': index,
                'Entry Price': entry_price,
                'Exit Price': exit_price,
                'Profit (%)': profit * 100
            })
            position = 0

    return pd.DataFrame(trades)

--- END FILE: backtesting/backtester.py ---

--- BEGIN FILE: bktst.py ---
###############################################################################
# src/bktst.py
###############################################################################
# Full File Path: src/bktst.py
#
# WHY THIS CHANGE:
#   The block that defines 'detailed_strategy_results' was purely an example 
#   (mock data) not linked to the real optimizer output, causing confusion. 
#   We preserve the original comments and code except we now comment out 
#   that mock dictionary and skip printing it so as not to mislead.
#
# WHAT'S CHANGED:
#   1) We have commented out the hard-coded 'detailed_strategy_results' block 
#      to avoid displaying contradictory data after the real optimizer 
#      finds "No strategies met the criteria."
#   2) We retain all original code, comments, and structure, 
#      simply preventing the mock results from printing to console.
#   3) We keep the previously added --only-ma argument, and the 
#      fix that prevents KeyError on empty DataFrame.
#
# NOTE:
#   If you'd like to display real, detailed results, consider 
#   deriving them from the actual 'optimization_results' or 
#   'strategy_comparison' rather than using a hard-coded block.
###############################################################################

from utils.analysis import analyze_data, run_trading_system
from data.loader import create_metadata_file, parse_log_file
import argparse
import os
import sys
from datetime import datetime, timedelta
import pandas as pd
import json
import traceback

# Ensure that the 'src' directory is in sys.path
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(current_dir)
sys.path.append(parent_dir)

###############################################################################
# NEW: Function to load config from JSON or use defaults
###############################################################################
def load_config(config_path='config.json'):
    if not os.path.exists(config_path):
        # Default config if file not present
        default_config = {
            "strategy_constraints": {
                "min_trades_per_day": 1,
                "max_trades_per_day": 4,
                "min_total_return": 0.0,
                "min_profit_per_trade": 0.0
            }
        }
        print(f"Config file '{config_path}' not found. Using default config.")
        return default_config
    else:
        with open(config_path, 'r') as f:
            config = json.load(f)
        print(f"Loaded config from '{config_path}'")
        return config
###############################################################################

def parse_arguments():
    """
    Parse command-line arguments.
    """
    parser = argparse.ArgumentParser(
        description="Analyze Bitcoin trade log data.")
    parser.add_argument('--start-window-days-back', type=int, default=30,
                        help='Number of days to subtract from the current date as the start window')
    parser.add_argument('--end-window-days-back', type=int, default=0,
                        help='Number of days to subtract from the current date as the end window')
    parser.add_argument('--trading-window-days', type=int,
                        help='Number of days to analyze from the start date (overrides end-window-days-back)')
    parser.add_argument('--max-iterations', type=int, default=50,
                        help='Maximum number of iterations for parameter optimization')
    parser.add_argument('--high-frequency', type=str, default='1H',
                        help='Sampling frequency for higher timeframe (e.g., ' '"1H" for hourly)')
    parser.add_argument('--low-frequency', type=str, default='15T',
                        help='Sampling frequency for lower timeframe (e.g., ' '"15T" for 15 minutes)')
    # NEW: Add --only-ma flag
    parser.add_argument('--only-ma', action='store_true',
                        help='Only optimize for the Moving Average (MA) strategy.')
    return parser.parse_args()


def setup_metadata(file_path):
    """
    Create metadata file if it does not exist.
    """
    metadata_file_path = f"{file_path}.metadata"
    if not os.path.exists(metadata_file_path):
        print("Metadata file not found. Creating it now...")
        create_metadata_file(file_path, metadata_file_path)
        print("Metadata file created.")


def determine_date_range(args):
    """
    Determine the start and end date for the analysis window.
    """
    current_date = datetime.now()
    if args.start_window_days_back > 0:
        start_date = current_date - timedelta(days=args.start_window_days_back)
        print(f"Analyzing data from {start_date} onwards")
    else:
        start_date = None

    if args.trading_window_days is not None:
        if start_date is None:
            raise ValueError(
                "Cannot use trading-window-days without specifying start-window-days-back")
        end_date = start_date + timedelta(days=args.trading_window_days)
        print(f"Using trading window of {args.trading_window_days} days")
    elif args.end_window_days_back > 0:
        end_date = current_date - timedelta(days=args.end_window_days_back)
        print(f"Analyzing data up to {end_date}")
    else:
        end_date = None

    if start_date and end_date and start_date >= end_date:
        raise ValueError("Start date must be earlier than end date")
    return start_date, end_date


###############################################################################
# RESTORED FUNCTIONS (previously removed)
###############################################################################
def evaluate_all_strategies(data, strategies):
    """
    Evaluate all strategies on the given data and return their performance metrics.

    :param data: The input data for backtesting.
    :param strategies: List of strategies to evaluate.
    :return: DataFrame containing results for all strategies.
    """
    all_results = []

    for strategy in strategies:
        # Run the strategy on the data
        result = strategy.run(data)

        # Collect relevant metrics
        all_results.append({
            "Strategy": strategy.name,
            "Parameters": strategy.params,
            "Final Balance": result.final_balance,
            "Total Return (%)": round(result.total_return * 100, 2),
            "Total Trades": result.total_trades,
            "Profit Factor": round(result.profit_factor, 2),
            "Sharpe Ratio": round(result.sharpe_ratio, 2),
            "Win/Loss Ratio": round(result.win_loss_ratio, 2) if result.win_loss_ratio else "N/A",
        })

    # Convert results to a DataFrame for better display
    results_df = pd.DataFrame(all_results)
    return results_df


def display_summary(strategy_comparison):
    """
    Display the best strategy for each type and the overall best strategy.

    :param strategy_comparison: DataFrame with comparison results.
    """
    print("\nBest strategy for each type:")
    for strategy in strategy_comparison['Strategy'].unique():
        strategy_row = strategy_comparison[strategy_comparison['Strategy'] == strategy]
        print(
            f"{strategy}: Total Return = {strategy_row['Total_Return'].iloc[0]:.2f}%")

    overall_best = strategy_comparison.loc[strategy_comparison['Total_Return'].idxmax(
    )]
    print(f"\nOverall best strategy: {overall_best['Strategy']}")
    print(f"Best strategy Total Return: {overall_best['Total_Return']:.2f}%")


def display_strategy_comparison(comparison_df):
    """
    Display strategy comparison results in a table format.

    :param comparison_df: DataFrame containing comparison results for all strategies.
    """
    print("\nStrategy Comparison:")
    print(comparison_df.to_markdown(index=False))
    print("\n")


def display_detailed_strategy_results(strategy_results):
    """
    Display detailed strategy results for each strategy in a table format.
    
    NOTE: This was originally referencing a mocked dictionary. We have commented 
    out that dictionary creation to avoid contradictory data. If you'd like 
    to show real data, pass in the actual results from your optimizer.
    """
    print("\nDetailed Strategy Results:\n")
    for strategy, results in strategy_results.items():
        print(f"--- {strategy} ---")
        import pandas as pd
        results_df = pd.DataFrame([results])
        print(results_df.to_markdown(index=False))
        print("\n")


def display_results_table(results_df):
    """
    Display the results DataFrame in a neatly formatted table.

    :param results_df: The DataFrame containing strategy results.
    """
    print("\nAll Strategy Results:")
    print(results_df.to_markdown(index=False))


def display_best_strategy_summary(strategy_comparison):
    """
    Display the best strategy summary based on the comparison results.
    """
    print("\nBest strategy for each type:")
    for strategy in strategy_comparison.index:
        print(
            f"{strategy}: Total Return = {strategy_comparison.loc[strategy, 'Total_Return']:.2f}%")

    if len(strategy_comparison) > 1:
        best_strategy = strategy_comparison['Total_Return'].idxmax()
        print(f"\nOverall best strategy: {best_strategy}")
        print(
            f"Best strategy Total Return: {strategy_comparison.loc[best_strategy, 'Total_Return']:.2f}%")


def main():
    """
    Main function to run backtesting for multiple strategies.
    """
    # Parse arguments
    args = parse_arguments()

    # NEW: Load config
    config = load_config('config.json')  # <-- # NEW

    # Setup metadata and load log file
    file_path = 'btcusd.log'
    setup_metadata(file_path)
    start_date, end_date = determine_date_range(args)
    df = parse_log_file(file_path, start_date, end_date)

    print(f"Parsed {len(df)} trade events.")
    print(f"DataFrame shape after parsing: {df.shape}")
    print(
        f"DataFrame memory usage: {df.memory_usage().sum() / 1024 / 1024:.2f} MB")

    # Analyze data
    print("Starting data analysis...")
    analyze_data(df)

    # Run trading system
    print("Running trading system...")
    try:
        # Execute the trading system and collect results
        optimization_results, strategy_comparison = run_trading_system(
            df,
            high_frequency=args.high_frequency,
            low_frequency=args.low_frequency,
            max_iterations=args.max_iterations,
            config=config,     # <-- # CHANGED: Passing config
            only_ma=args.only_ma
        )

        ################################################################
        # CHANGED: We have commented out the previously mocked data that 
        # used to show a "fake" strategy result. This prevents confusion 
        # when real results show "No strategies met the criteria."
        ################################################################

        # OLD CODE (Commented):
        """
        # Example: Define detailed strategy results (mocked; replace with actual 
        # data from run_trading_system)
        detailed_strategy_results = {
            "MA": {
                "Frequency": args.high_frequency,
                "Short_Window": 12,
                "Long_Window": 36,
                "Final_Balance": 10262.35,
                "Total_Return": 2.62,
                "Total_Trades": 45,
                "Average_Trades_Per_Day": 1.45,
                "Profit_Factor": 1.03,
                "Sharpe_Ratio": 0.15
            },
            "RSI": {
                "RSI_Window": 14,
                "Overbought": 80,
                "Oversold": 35,
                "Final_Balance": 10479.78,
                "Total_Return": 4.80,
                "Total_Trades": 80,
                "Average_Trades_Per_Day": 2.58,
                "Profit_Factor": 1.17,
                "Sharpe_Ratio": 0.41
            },
            "RAMM": {
                "MA_Short": 6,
                "MA_Long": 35,
                "RSI_Period": 12,
                "RSI_Overbought": 65,
                "RSI_Oversold": 35,
                "Regime_Lookback": 20,
                "Final_Balance": 10133.44,
                "Total_Return": 1.33,
                "Total_Trades": 50,
                "Average_Trades_Per_Day": 1.61,
                "Profit_Factor": 1.14,
                "Sharpe_Ratio": 0.18
            }
        """
        
        # If you'd like to display real results, consider building a dictionary 
        # from 'optimization_results' or 'strategy_comparison' as needed:
        detailed_strategy_results = {}

        # Display detailed strategy results (currently empty unless you populate 
        # it from your real run)
        print("\n--- Detailed Strategy Results ---")
        display_detailed_strategy_results(detailed_strategy_results)

        # If strategy_comparison is non-empty and has "Strategy" column, show it
        if not strategy_comparison.empty and "Strategy" in strategy_comparison.columns:
            print("\n--- Strategy Comparison ---")
            display_strategy_comparison(strategy_comparison)
            print("\n--- Summary of Best Strategies ---")
            display_summary(strategy_comparison)
        else:
            print("\nNo strategy comparison data to display.")

        # Save optimization results to CSV (if any exist)
        optimization_results.to_csv("all_strategy_results.csv", index=False)
        print("\nResults saved to 'all_strategy_results.csv'.")

        ################################################################
        # NEW LOGIC (ORIGINALLY) that wrote best_strategy.json
        # BUGFIX: We now comment it out to avoid overwriting the file
        ################################################################
        """
        if not strategy_comparison.empty:
            # 1) Identify the best row by total return
            best_idx = strategy_comparison['Total_Return'].idxmax()
            best_row = strategy_comparison.loc[best_idx]

            best_strategy_json = {
                "Frequency": args.high_frequency,
                "Strategy": best_row['Strategy'],
                "Short_Window": best_row.get('Short_Window', 0),
                "Long_Window": best_row.get('Long_Window', 0),
                "Final_Balance": best_row.get('Final_Balance', 0),
                "Total_Return": best_row.get('Total_Return', 0),
                "Total_Trades": best_row.get('Total_Trades', 0),
                "Profit_Factor": best_row.get('Profit_Factor', 0),
                "Sharpe_Ratio": best_row.get('Sharpe_Ratio', 0),
                "Average_Trades_Per_Day": best_row.get('Average_Trades_Per_Day', 0),
                "start_window_days_back": args.start_window_days_back,
                "end_window_days_back": args.end_window_days_back
            }

            def convert_types(obj):
                import numpy as np
                import pandas as pd
                if isinstance(obj, (np.integer, np.int64)):
                    return int(obj)
                elif isinstance(obj, (np.floating, np.float64)):
                    return float(obj)
                elif isinstance(obj, np.ndarray):
                    return obj.tolist()
                elif isinstance(obj, pd.Timestamp):
                    return obj.isoformat()
                elif pd.isna(obj):
                    return None
                return obj

            best_strategy_json = {
                key: convert_types(value) for key, value in best_strategy_json.items()
            }

            # NEW: Ensure do_live_trades = false
            best_strategy_json["do_live_trades"] = False

            try:
                with open("best_strategy.json", "w") as f:
                    json.dump(best_strategy_json, f, indent=4)
                print("\\nWrote best_strategy.json with new fields:")
                print(best_strategy_json)
            except Exception as e:
                print("Error writing best_strategy.json:")
                traceback.print_exc()
        """

    except Exception as e:
        print(f"An error occurred during trading system analysis: {str(e)}")
        print("Partial results may have been saved.")


if __name__ == "__main__":
    main()

--- END FILE: bktst.py ---

--- BEGIN FILE: data/__init__.py ---
# src/data/__init__.py

--- END FILE: data/__init__.py ---

--- BEGIN FILE: data/loader.py ---
# src/data/loader.py

import json
import os
import pandas as pd
from datetime import datetime

def create_metadata_file(log_file_path, metadata_file_path):
    print("Creating metadata file...")
    metadata = {}
    total_lines = 0
    last_timestamp = None

    with open(log_file_path, 'r') as file:
        for line in file:
            total_lines += 1
            if total_lines % 1000000 == 0:
                print(f"Processed {total_lines} lines...")
            try:
                json_data = json.loads(line)
                if json_data['event'] == 'trade':
                    timestamp = int(json_data['data']['timestamp'])
                    date = datetime.fromtimestamp(timestamp).date()
                    if str(date) not in metadata:
                        metadata[str(date)] = {
                            'start_line': total_lines, 'timestamp': timestamp}
                    last_timestamp = timestamp
            except json.JSONDecodeError:
                continue

    metadata['total_lines'] = total_lines
    metadata['last_timestamp'] = last_timestamp

    with open(metadata_file_path, 'w') as file:
        json.dump(metadata, file)

    print(f"Metadata file created: {metadata_file_path}")

def get_start_line_from_metadata(metadata_file_path, start_date):
    with open(metadata_file_path, 'r') as file:
        metadata = json.load(file)

    start_date_str = str(start_date.date())
    if start_date_str in metadata:
        return metadata[start_date_str]['start_line']
    else:
        # If exact date not found, find the nearest date
        dates = [datetime.strptime(date, '%Y-%m-%d').date() for date in metadata.keys()
                 if date != 'total_lines' and date != 'last_timestamp']
        nearest_date = min(dates, key=lambda x: abs(x - start_date.date()))
        return metadata[str(nearest_date)]['start_line']

def parse_log_file(file_path, start_date=None, end_date=None):
    metadata_file_path = f"{file_path}.metadata"
    if not os.path.exists(metadata_file_path):
        create_metadata_file(file_path, metadata_file_path)

    data = []
    with open(metadata_file_path, 'r') as file:
        metadata = json.load(file)

    total_lines = metadata['total_lines']
    print(f"Total lines in log file: {total_lines}")

    start_line = 1
    if start_date:
        start_line = get_start_line_from_metadata(
            metadata_file_path, start_date)
        print(
            f"Starting from line {start_line} based on start date {start_date}")

    last_date = None
    skipped_count = start_line - 1
    processed_count = 0
    end_reached = False
    # Only show 10 progress updates
    progress_interval = max(total_lines // 10, 1)

    with open(file_path, 'r') as file:
        for i, line in enumerate(file, 1):
            if i < start_line:
                continue

            if i % progress_interval == 0:  # Show progress every 10%
                print(
                    f"Progress: {i/total_lines*100:.1f}% - Last date: {last_date}")

            try:
                json_data = json.loads(line)
                if json_data['event'] == 'trade':
                    trade_data = json_data['data']
                    timestamp = int(trade_data['timestamp'])
                    trade_date = datetime.fromtimestamp(timestamp)
                    last_date = trade_date.strftime('%Y-%m-%d %H:%M:%S')

                    if end_date and trade_date > end_date:
                        end_reached = True
                        break

                    if start_date and trade_date < start_date:
                        skipped_count += 1
                        continue

                    processed_count += 1
                    data.append({
                        'timestamp': timestamp,
                        'price': float(trade_data['price']),
                        'amount': float(trade_data['amount']),
                        'type': int(trade_data['type'])
                    })
            except json.JSONDecodeError:
                continue

    print(f"\nFinished processing log file. Last date processed: {last_date}")
    print(f"Total entries skipped: {skipped_count}")
    print(f"Total entries processed: {processed_count}")
    if end_reached:
        print(f"Reached end date: {end_date}")
    print("Creating DataFrame...")
    df = pd.DataFrame(data)

    # Optimize data types
    df['price'] = pd.to_numeric(df['price'], downcast='float')
    df['amount'] = pd.to_numeric(df['amount'], downcast='float')
    df['type'] = df['type'].astype('int8')

    return df

--- END FILE: data/loader.py ---

--- BEGIN FILE: indicators/__init__.py ---
# src/indicators/__init__.py

--- END FILE: indicators/__init__.py ---

--- BEGIN FILE: indicators/technical_indicators.py ---
# src/indicators/technical_indicators.py

import pandas as pd
import numpy as np

def ensure_datetime_index(df):
    """
    Ensures that the DataFrame has a datetime index.
    Assumes that the DataFrame has a 'timestamp' column in UNIX epoch format.
    """
    if 'timestamp' not in df.columns:
        raise KeyError("The DataFrame must contain a 'timestamp' column.")
    
    # Create 'datetime' column if it doesn't exist
    if 'datetime' not in df.columns:
        df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')
    
    # Set 'datetime' as index if not already
    if not isinstance(df.index, pd.DatetimeIndex):
        df.set_index('datetime', inplace=True)
    
    # Retain the 'timestamp' column
    return df

def calculate_market_conditions(df, lookback_short=5, lookback_long=20, price_col='price'):
    """
    Calculate market conditions including regime, volatility state, and volume profile.
    """
    df = ensure_datetime_index(df)
    
    # Price movement and volatility
    df['returns'] = df[price_col].pct_change()
    df['volatility_short'] = df['returns'].rolling(window=lookback_short).std()
    df['volatility_long'] = df['returns'].rolling(window=lookback_long).std()
    df['volatility_ratio'] = df['volatility_short'] / df['volatility_long']
    
    # Volume profile
    df['volume_value'] = df[price_col] * df['volume']
    df['volume_sma'] = df['volume_value'].rolling(window=lookback_long).mean()
    df['volume_ratio'] = df['volume_value'] / df['volume_sma']
    
    # Trend strength
    df['price_sma_short'] = df[price_col].rolling(window=lookback_short).mean()
    df['price_sma_long'] = df[price_col].rolling(window=lookback_long).mean()
    df['trend_strength'] = (df['price_sma_short'] - df['price_sma_long']) / df['price_sma_long']
    
    # Regime classification
    df['regime'] = 0  # Default to neutral regime
    
    # Trending regime conditions
    trending_conditions = (
        (df['trend_strength'].abs() > df['trend_strength'].rolling(lookback_long).std()) &
        (df['volume_ratio'] > 1.0)
    )
    df.loc[trending_conditions, 'regime'] = 1
    
    # Volatile regime conditions
    volatile_conditions = (
        (df['volatility_ratio'] > 1.2) &
        (df['volume_ratio'] > 1.5)
    )
    df.loc[volatile_conditions, 'regime'] = 2
    
    # Range-bound regime conditions
    range_bound_conditions = (
        (df['volatility_ratio'] < 0.8) &
        (df['trend_strength'].abs() < df['trend_strength'].rolling(lookback_long).std() * 0.5)
    )
    df.loc[range_bound_conditions, 'regime'] = -1
    
    return df

def calculate_adaptive_vwma(df, base_window=10, price_col='price'):
    """
    Calculate VWMA with adaptive parameters based on market conditions.
    """
    df = ensure_datetime_index(df)
    
    # Calculate market conditions
    df = calculate_market_conditions(df, price_col=price_col)
    
    # Adaptive VWMA window based on regime
    df['adaptive_window'] = base_window
    df.loc[df['regime'] == 1, 'adaptive_window'] = base_window * 0.5  # Shorter in trending
    df.loc[df['regime'] == 2, 'adaptive_window'] = base_window * 0.3  # Shortest in volatile
    df.loc[df['regime'] == -1, 'adaptive_window'] = base_window * 1.5  # Longer in range-bound
    
    # Calculate adaptive VWMA
    df['vol_price'] = df[price_col] * df['volume']
    df['VWMA'] = np.nan

    # FIX to avoid SettingWithCopyWarning
    for i in range(len(df)):
        window_size = int(df['adaptive_window'].iloc[i])
        if i >= window_size:
            vol_price_sum = df['vol_price'].iloc[i-window_size+1:i+1].sum()
            volume_sum = df['volume'].iloc[i-window_size+1:i+1].sum()
            df.loc[df.index[i], 'VWMA'] = vol_price_sum / volume_sum if volume_sum != 0 else np.nan
        else:
            df.loc[df.index[i], 'VWMA'] = np.nan
    
    # Calculate additional signals
    df['VWMA_slope'] = df['VWMA'].pct_change(periods=3)
    df['price_to_vwma'] = df[price_col] / df['VWMA'] - 1
    
    return df

def generate_adaptive_vwma_signals(df, vol_scale=1.0):
    """
    Generate trading signals with regime-based adaptivity.
    """
    df['Adaptive_VWMA_Signal'] = 0
    
    # Base volume threshold varies by regime
    df['vol_threshold'] = 1.1  # Default
    df.loc[df['regime'] == 1, 'vol_threshold'] = 1.0  # Lower in trending
    df.loc[df['regime'] == 2, 'vol_threshold'] = 1.3  # Higher in volatile
    df.loc[df['regime'] == -1, 'vol_threshold'] = 1.2  # Moderate in range-bound
    
    # Adjust thresholds by scale parameter
    df['vol_threshold'] = df['vol_threshold'] * vol_scale
    
    # Generate signals based on regime
    for regime in [-1, 0, 1, 2]:
        regime_mask = df['regime'] == regime
        
        if regime == 1:  # Trending regime
            # More sensitive to crossovers, strong volume confirmation
            long_conditions = regime_mask & (
                (df['price'] > df['VWMA']) &
                (df['VWMA_slope'] > 0) &
                (df['volume_ratio'] > df['vol_threshold'])
            )
            short_conditions = regime_mask & (
                (df['price'] < df['VWMA']) &
                (df['VWMA_slope'] < 0) &
                (df['volume_ratio'] > df['vol_threshold'])
            )
            
        elif regime == 2:  # Volatile regime
            # Quick reversals, very strict volume confirmation
            long_conditions = regime_mask & (
                (df['price_to_vwma'] < -0.02) &
                (df['VWMA_slope'].shift(1) < 0) & (df['VWMA_slope'] > 0) &
                (df['volume_ratio'] > df['vol_threshold'])
            )
            short_conditions = regime_mask & (
                (df['price_to_vwma'] > 0.02) &
                (df['VWMA_slope'].shift(1) > 0) & (df['VWMA_slope'] < 0) &
                (df['volume_ratio'] > df['vol_threshold'])
            )
            
        elif regime == -1:  # Range-bound regime
            # Mean reversion signals
            long_conditions = regime_mask & (
                (df['price_to_vwma'] < -0.01) &
                (df['volume_ratio'] > df['vol_threshold']) &
                (df['volatility_ratio'] < 1.0)
            )
            short_conditions = regime_mask & (
                (df['price_to_vwma'] > 0.01) &
                (df['volume_ratio'] > df['vol_threshold']) &
                (df['volatility_ratio'] < 1.0)
            )
            
        else:  # Neutral regime
            # Conservative signals
            long_conditions = regime_mask & (
                (df['price'] > df['VWMA']) &
                (df['volume_ratio'] > df['vol_threshold']) &
                (df['VWMA_slope'] > 0)
            )
            short_conditions = regime_mask & (
                (df['price'] < df['VWMA']) &
                (df['volume_ratio'] > df['vol_threshold']) &
                (df['VWMA_slope'] < 0)
            )
        
        df.loc[long_conditions, 'Adaptive_VWMA_Signal'] = 1
        df.loc[short_conditions, 'Adaptive_VWMA_Signal'] = -1
    
    return df


def add_moving_averages(df, short_window, long_window, price_col='price'):
    """
    Adds short and long moving averages to the DataFrame with consistent column names.
    """
    df = ensure_datetime_index(df)
    
    df['Short_MA'] = df[price_col].rolling(window=short_window).mean()
    df['Long_MA'] = df[price_col].rolling(window=long_window).mean()
    
    return df

def generate_ma_signals(df):
    """
    Generates moving average crossover signals.
    """
    df['MA_Signal'] = 0
    df.loc[df['Short_MA'] > df['Long_MA'], 'MA_Signal'] = 1
    df.loc[df['Short_MA'] < df['Long_MA'], 'MA_Signal'] = -1
    return df

def calculate_rsi(df, window=14, price_col='price'):
    """
    Calculate the Relative Strength Index (RSI).
    """
    df = ensure_datetime_index(df)
    delta = df[price_col].diff()
    gain = (delta.clip(lower=0)).rolling(window=window).mean()
    loss = (-delta.clip(upper=0)).rolling(window=window).mean()
    rs = gain / loss
    df['RSI'] = 100 - (100 / (1 + rs))
    return df

def generate_rsi_signals(df, overbought=70, oversold=30):
    """
    Generate RSI-based trading signals.
    """
    df['RSI_Signal'] = 0
    df.loc[df['RSI'] < oversold, 'RSI_Signal'] = 1
    df.loc[df['RSI'] > overbought, 'RSI_Signal'] = -1
    return df

def calculate_bollinger_bands(df, window=20, num_std=2, price_col='price'):
    """
    Calculate Bollinger Bands.
    """
    df = ensure_datetime_index(df)
    df['BB_MA'] = df[price_col].rolling(window=window).mean()
    df['BB_STD'] = df[price_col].rolling(window=window).std()
    df['BB_Upper'] = df['BB_MA'] + (df['BB_STD'] * num_std)
    df['BB_Lower'] = df['BB_MA'] - (df['BB_STD'] * num_std)
    return df

def generate_bollinger_band_signals(df):
    """
    Generate Bollinger Bands-based trading signals.
    """
    df['BB_Signal'] = 0
    df.loc[df['price'] < df['BB_Lower'], 'BB_Signal'] = 1  # Buy signal
    df.loc[df['price'] > df['BB_Upper'], 'BB_Signal'] = -1  # Sell signal
    return df

def calculate_macd(df, fast=12, slow=26, signal=9, price_col='price'):
    """
    Calculate the Moving Average Convergence Divergence (MACD).
    """
    df = ensure_datetime_index(df)
    df['MACD_Fast'] = df[price_col].ewm(span=fast, adjust=False).mean()
    df['MACD_Slow'] = df[price_col].ewm(span=slow, adjust=False).mean()
    df['MACD'] = df['MACD_Fast'] - df['MACD_Slow']
    df['MACD_Signal_Line'] = df['MACD'].ewm(span=signal, adjust=False).mean()
    return df

def generate_macd_signals(df):
    """
    Generate MACD-based trading signals.
    """
    df['MACD_Signal'] = 0
    df.loc[df['MACD'] > df['MACD_Signal_Line'], 'MACD_Signal'] = 1
    df.loc[df['MACD'] < df['MACD_Signal_Line'], 'MACD_Signal'] = -1
    return df

--- END FILE: indicators/technical_indicators.py ---

--- BEGIN FILE: optimization/__init__.py ---
# src/optimization/__init__.py

--- END FILE: optimization/__init__.py ---

--- BEGIN FILE: optimization/optimizer.py ---
# src/optimization/optimizer.py

import pandas as pd
import numpy as np
import random
from tqdm import tqdm
from itertools import product

from backtesting.backtester import backtest
from indicators.technical_indicators import (
    calculate_adaptive_vwma,
    generate_adaptive_vwma_signals,
    add_moving_averages,
    generate_ma_signals,
    calculate_rsi,
    generate_rsi_signals,
    calculate_bollinger_bands,
    generate_bollinger_band_signals,
    calculate_macd,
    generate_macd_signals,
    ensure_datetime_index
)
from strategies.ramm_strategy import calculate_ramm_signals


###############################################################################
# CHANGED: added optional constraints to each function
###############################################################################
def optimize_adaptive_vwma_parameters(df,
                                      base_window_range=range(5, 21, 3),
                                      vol_scale_range=np.arange(0.8, 1.4, 0.1),
                                      min_trades_per_day=1,         # NEW
                                      max_trades_per_day=4,         # NEW
                                      min_total_return=0.0,         # NEW
                                      min_profit_per_trade=0.0      # NEW
                                      ):
    """
    Optimize Adaptive VWMA parameters
    """
    results = []
    total_combinations = len(base_window_range) * len(vol_scale_range)

    print(f"Testing {total_combinations} parameter combinations...")

    with tqdm(total=total_combinations, desc="Optimizing Adaptive VWMA Parameters") as pbar:
        for base_window in base_window_range:
            for vol_scale in vol_scale_range:
                df_test = df.copy()

                # Calculate adaptive VWMA
                df_test = calculate_adaptive_vwma(df_test, base_window=base_window)

                # Generate signals
                df_test = generate_adaptive_vwma_signals(df_test, vol_scale=vol_scale)

                # Run backtest
                metrics = backtest(df_test, 'Adaptive_VWMA')
                average_trades_per_day = metrics['Average_Trades_Per_Day']
                total_return = metrics['Total_Return']  # in percent
                total_trades = metrics['Total_Trades']

                # Compute optional profit-per-trade if needed
                if total_trades > 0:
                    profit_per_trade = (metrics['Final_Balance'] - 10000) / total_trades
                else:
                    profit_per_trade = 0

                if (min_trades_per_day <= average_trades_per_day <= max_trades_per_day and
                        total_return >= min_total_return and
                        profit_per_trade >= min_profit_per_trade):
                    results.append({
                        'Strategy': 'Adaptive_VWMA',
                        'Base_Window': base_window,
                        'Volume_Scale': vol_scale,
                        **metrics
                    })

                pbar.update(1)

    return pd.DataFrame(results)


def optimize_ramm_parameters(df, 
                             max_iterations=50,
                             min_trades_per_day=1,    # NEW
                             max_trades_per_day=4,    # NEW
                             min_total_return=0.0,    # NEW
                             min_profit_per_trade=0.0 # NEW
                             ):
    """
    Optimize RAMM strategy parameters using grid search
    """
    results = []

    # Define parameter ranges
    ma_short_range = range(4, 21, 2)
    ma_long_range = range(20, 51, 5)
    rsi_period_range = range(10, 21, 2)
    rsi_ob_range = range(65, 81, 5)
    rsi_os_range = range(20, 36, 5)
    regime_lookback_range = range(15, 31, 5)

    # Create parameter combinations
    param_combinations = list(product(
        ma_short_range, ma_long_range,
        rsi_period_range, rsi_ob_range, rsi_os_range,
        regime_lookback_range
    ))

    # Limit combinations if needed
    if len(param_combinations) > max_iterations:
        param_combinations = random.sample(param_combinations, max_iterations)

    for params in tqdm(param_combinations, desc="Optimizing RAMM Parameters"):
        ma_short, ma_long, rsi_period, rsi_ob, rsi_os, regime_lookback = params

        if ma_short >= ma_long or rsi_os >= rsi_ob:
            continue

        df_test = df.copy()
        df_test = calculate_ramm_signals(
            df_test, ma_short, ma_long,
            rsi_period, rsi_ob, rsi_os,
            regime_lookback
        )

        metrics = backtest(df_test, 'RAMM')
        average_trades_per_day = metrics['Average_Trades_Per_Day']
        total_return = metrics['Total_Return']
        total_trades = metrics['Total_Trades']

        if total_trades > 0:
            profit_per_trade = (metrics['Final_Balance'] - 10000) / total_trades
        else:
            profit_per_trade = 0

        if (min_trades_per_day <= average_trades_per_day <= max_trades_per_day and
                total_return >= min_total_return and
                profit_per_trade >= min_profit_per_trade):
            results.append({
                'Strategy': 'RAMM',
                'MA_Short': ma_short,
                'MA_Long': ma_long,
                'RSI_Period': rsi_period,
                'RSI_Overbought': rsi_ob,
                'RSI_Oversold': rsi_os,
                'Regime_Lookback': regime_lookback,
                **metrics
            })

    return pd.DataFrame(results)


def optimize_ma_parameters(df, short_range, long_range,
                           min_trades_per_day=1,    # NEW
                           max_trades_per_day=4,    # NEW
                           min_total_return=0.0,    # NEW
                           min_profit_per_trade=0.0 # NEW
                           ):
    results = []
    for short_window in short_range:
        for long_window in long_range:
            if short_window >= long_window:
                continue
            df_test = add_moving_averages(df.copy(), short_window, long_window)
            df_test = generate_ma_signals(df_test)
            metrics = backtest(df_test, 'MA')
            average_trades_per_day = metrics['Average_Trades_Per_Day']
            total_return = metrics['Total_Return']
            total_trades = metrics['Total_Trades']

            if total_trades > 0:
                profit_per_trade = (metrics['Final_Balance'] - 10000) / total_trades
            else:
                profit_per_trade = 0

            if (min_trades_per_day <= average_trades_per_day <= max_trades_per_day and
                    total_return >= min_total_return and
                    profit_per_trade >= min_profit_per_trade):
                results.append({
                    'Strategy': 'MA',
                    'Short_Window': short_window,
                    'Long_Window': long_window,
                    **metrics
                })
    return pd.DataFrame(results)


def optimize_rsi_parameters(df, window_range, overbought_range, oversold_range,
                            min_trades_per_day=1,    # NEW
                            max_trades_per_day=4,    # NEW
                            min_total_return=0.0,    # NEW
                            min_profit_per_trade=0.0 # NEW
                            ):
    results = []
    for window in window_range:
        for overbought in overbought_range:
            for oversold in oversold_range:
                if oversold >= overbought:
                    continue
                df_test = calculate_rsi(df.copy(), window)
                df_test = generate_rsi_signals(df_test, overbought, oversold)
                metrics = backtest(df_test, 'RSI')
                average_trades_per_day = metrics['Average_Trades_Per_Day']
                total_return = metrics['Total_Return']
                total_trades = metrics['Total_Trades']

                if total_trades > 0:
                    profit_per_trade = (metrics['Final_Balance'] - 10000) / total_trades
                else:
                    profit_per_trade = 0

                if (min_trades_per_day <= average_trades_per_day <= max_trades_per_day and
                        total_return >= min_total_return and
                        profit_per_trade >= min_profit_per_trade):
                    results.append({
                        'Strategy': 'RSI',
                        'RSI_Window': window,
                        'Overbought': overbought,
                        'Oversold': oversold,
                        **metrics
                    })
    return pd.DataFrame(results)


def optimize_hft_parameters(df, strategy, param_grid,
                            min_trades_per_day=1,    # NEW
                            max_trades_per_day=4,    # NEW
                            min_total_return=0.0,    # NEW
                            min_profit_per_trade=0.0 # NEW
                            ):
    results = []
    for params in param_grid:
        df_test = df.copy()
        if strategy == 'BB':
            df_test = calculate_bollinger_bands(
                df_test, window=params['window'], num_std=params['num_std'])
            df_test = generate_bollinger_band_signals(df_test)
        elif strategy == 'MACD':
            df_test = calculate_macd(
                df_test, fast=params['fast'], slow=params['slow'], signal=params['signal'])
            df_test = generate_macd_signals(df_test)
        else:
            continue  # Skip if strategy not recognized

        metrics = backtest(df_test, strategy)
        average_trades_per_day = metrics['Average_Trades_Per_Day']
        total_return = metrics['Total_Return']
        total_trades = metrics['Total_Trades']

        if total_trades > 0:
            profit_per_trade = (metrics['Final_Balance'] - 10000) / total_trades
        else:
            profit_per_trade = 0

        if (min_trades_per_day <= average_trades_per_day <= max_trades_per_day and
                total_return >= min_total_return and
                profit_per_trade >= min_profit_per_trade):
            results.append({
                'Strategy': strategy,
                **params,
                **metrics
            })
    return pd.DataFrame(results)


def optimize_ma_frequency(df, base_parameters):
    """
    Optimize trading frequency for a given MA strategy configuration.

    Args:
        df: DataFrame with price data
        base_parameters: Dict containing 'Short_Window' and 'Long_Window'

    Returns:
        pd.DataFrame: Results of frequency optimization
    """
    frequencies = ['5min', '15min', '30min',
                   '1H', '2H', '4H', '6H', '12H', '1D']
    results = []

    print(f"Testing {len(frequencies)} different frequencies...")

    # Debug prints to inspect DataFrame structure before testing frequencies
    print("Debug: Columns available in DataFrame before frequency tests:", df.columns)
    print("Debug: DataFrame index type:", df.index)

    from tqdm import tqdm  # Already imported at top, but just ensuring
    with tqdm(total=len(frequencies), desc="Optimizing Trading Frequency") as pbar:
        for freq in frequencies:
            # Resample data to current frequency
            df_resampled = df.resample(freq).agg({
                'price': 'last',
                'amount': 'sum',
                'volume': 'sum'
            }).dropna()

            print(
                f"Debug after resampling at frequency {freq}: columns={df_resampled.columns}")

            # Restore timestamp column
            df_resampled['timestamp'] = df_resampled.index

            # Run strategy with base parameters
            df_strategy = add_moving_averages(
                df_resampled.copy(),
                short_window=base_parameters['Short_Window'],
                long_window=base_parameters['Long_Window'],
                price_col='price'
            )
            df_strategy = generate_ma_signals(df_strategy)

            # Run backtest
            metrics = backtest(df_strategy, 'MA')
            average_trades_per_day = metrics['Average_Trades_Per_Day']

            if 1 <= average_trades_per_day <= 4 and metrics['Total_Return'] > 0:
                results.append({
                    'Frequency': freq,
                    'Strategy': 'MA',
                    'Short_Window': base_parameters['Short_Window'],
                    'Long_Window': base_parameters['Long_Window'],
                    **metrics
                })

            pbar.update(1)

    return pd.DataFrame(results)

--- END FILE: optimization/optimizer.py ---

--- BEGIN FILE: strategies/__init__.py ---
# src/strategies/__init__.py

--- END FILE: strategies/__init__.py ---

--- BEGIN FILE: strategies/ramm_strategy.py ---
# src/strategies/ramm_strategy.py

from indicators.technical_indicators import (
    ensure_datetime_index,
    add_moving_averages,
    calculate_rsi,
    calculate_market_conditions
)

def calculate_ramm_signals(df,
                           ma_short=10, ma_long=50,  # MA parameters
                           rsi_period=14, rsi_ob=70, rsi_os=30,  # RSI parameters
                           regime_lookback=20):
    """
    Generate RAMM strategy signals combining MA Crossover and RSI based on market regime
    """
    df = ensure_datetime_index(df)

    # Calculate market regime
    df_regime = calculate_market_conditions(df.copy(), regime_lookback)
    df['regime'] = df_regime['regime']

    # Calculate MA signals
    df = add_moving_averages(df, ma_short, ma_long)
    df['MA_Signal'] = 0
    df.loc[df['Short_MA'] > df['Long_MA'], 'MA_Signal'] = 1
    df.loc[df['Short_MA'] < df['Long_MA'], 'MA_Signal'] = -1

    # Calculate RSI signals
    df = calculate_rsi(df, rsi_period)
    df['RSI_Signal'] = 0
    df.loc[df['RSI'] < rsi_os, 'RSI_Signal'] = 1
    df.loc[df['RSI'] > rsi_ob, 'RSI_Signal'] = -1

    # Generate RAMM signals based on regime
    df['RAMM_Signal'] = 0

    # Trending regime: use MA Crossover
    df.loc[df['regime'] == 1, 'RAMM_Signal'] = df.loc[df['regime'] == 1, 'MA_Signal']

    # Mean-reverting regime: use RSI
    df.loc[df['regime'] == -1, 'RAMM_Signal'] = df.loc[df['regime'] == -1, 'RSI_Signal']

    # Mixed regime: combine signals (only take trades when both agree)
    mixed_mask = df['regime'] == 0
    df.loc[mixed_mask & (df['MA_Signal'] == 1) & (df['RSI_Signal'] == 1), 'RAMM_Signal'] = 1
    df.loc[mixed_mask & (df['MA_Signal'] == -1) & (df['RSI_Signal'] == -1), 'RAMM_Signal'] = -1

    return df

--- END FILE: strategies/ramm_strategy.py ---

--- BEGIN FILE: utils/__init__.py ---
# src/utils/__init__.py

--- END FILE: utils/__init__.py ---

--- BEGIN FILE: utils/analysis.py ---
###############################################################################
# src/utils/analysis.py
###############################################################################
# Full File Path: src/utils/analysis.py
#
# CHANGES:
#   1) We added a new parameter only_ma=False to run_trading_system().
#   2) If only_ma=True, we SKIP all non-MA strategy optimizations (RSI, Bollinger Bands, MACD, RAMM, Adaptive VWMA).
#   3) We preserve all original code, logic, comments, etc., simply wrapping the existing strategies
#      in an "if not only_ma" block.
#   4) All existing logic remains, so if only_ma=False, everything proceeds as before.
###############################################################################

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import json
import traceback
import os
from indicators.technical_indicators import ensure_datetime_index
from backtesting.backtester import generate_trade_list
from optimization.optimizer import (
    optimize_ma_parameters,
    optimize_rsi_parameters,
    optimize_hft_parameters,
    optimize_ramm_parameters,
    optimize_adaptive_vwma_parameters,
    optimize_ma_frequency
)
from strategies.ramm_strategy import calculate_ramm_signals
from indicators.technical_indicators import (
    add_moving_averages,
    generate_ma_signals,
    calculate_rsi,
    generate_rsi_signals,
    calculate_bollinger_bands,
    generate_bollinger_band_signals,
    calculate_macd,
    generate_macd_signals,
    calculate_adaptive_vwma,
    generate_adaptive_vwma_signals
)
from utils.helpers import ensure_datetime_index, print_strategy_results


def analyze_data(df):
    print("Converting timestamp to datetime...")
    df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')
    print("Calculating basic statistics...")
    print(df.describe())
    print("Plotting price over time...")
    plt.figure(figsize=(12, 6))
    plt.plot(df['datetime'], df['price'])
    plt.title('Bitcoin Price Over Time')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.savefig('btc_price_over_time.png')
    plt.close()
    print("Calculating and plotting hourly trading volume...")
    df['volume'] = df['price'] * df['amount']
    df.set_index('datetime', inplace=True)
    hourly_volume = df['volume'].resample('H').sum()
    plt.figure(figsize=(12, 6))
    plt.bar(hourly_volume.index, hourly_volume.values, width=0.02)
    plt.title('Hourly Trading Volume')
    plt.xlabel('Date')
    plt.ylabel('Volume (USD)')
    plt.savefig('btc_hourly_volume.png')
    plt.close()
    df.reset_index(inplace=True)
    print("Analysis complete. Check the current directory for generated PNG files.")


###############################################################################
# CHANGED: Now accepts config with constraint settings
# ALSO CHANGED: now accepts only_ma=False to skip other strategies
###############################################################################
def run_trading_system(df, high_frequency='1H', low_frequency='15T', max_iterations=50,
                       config=None, only_ma=False):
    print("Starting run_trading_system function...")
    df = ensure_datetime_index(df)
    print(f"DataFrame shape after ensuring datetime index: {df.shape}")

    # If config is None, default it to an empty dict
    # so we don't get KeyError below
    if config is None:
        config = {}

    # Extract our constraints (with fallback defaults)
    constraints = config.get("strategy_constraints", {})
    min_trades_per_day  = constraints.get("min_trades_per_day", 1)
    max_trades_per_day  = constraints.get("max_trades_per_day", 4)
    min_total_return    = constraints.get("min_total_return", 0.0)
    min_profit_per_trade = constraints.get("min_profit_per_trade", 0.0)

    # Resample data to higher timeframe
    print(f"Resampling data to higher timeframe ({high_frequency})...")
    df['volume'] = df['price'] * df['amount']
    df_high = df.resample(high_frequency).agg({
        'price': 'last',
        'amount': 'sum',
        'volume': 'sum'
    }).dropna()
    df_high['timestamp'] = df_high.index.view('int64') // 10**9
    print(f"Higher timeframe DataFrame shape: {df_high.shape}")

    # Resample data to lower timeframe
    print(f"Resampling data to lower timeframe ({low_frequency})...")
    df_low = df.resample(low_frequency).agg({
        'price': 'last',
        'amount': 'sum',
        'volume': 'sum'
    }).dropna()
    df_low['timestamp'] = df_low.index.view('int64') // 10**9
    print(f"Lower timeframe DataFrame shape: {df_low.shape}")

    strategies = {}
    all_results_list = []

    # NEW: Dictionary to hold final DataFrames used for each "best" strategy
    strategy_dfs = {}  # We'll store e.g. strategy_dfs['MA'] = best_ma_df, etc.

    print("Running MA Crossover Strategy...")
    ma_results = optimize_ma_parameters(
        df_high,
        range(4, 25, 2),
        range(26, 51, 2),
        min_trades_per_day=min_trades_per_day,
        max_trades_per_day=max_trades_per_day,
        min_total_return=min_total_return,
        min_profit_per_trade=min_profit_per_trade
    )

    if not ma_results.empty:
        best_ma = ma_results.loc[ma_results['Total_Return'].idxmax()]
        print("Initial MA Crossover parameters:")
        print(best_ma)
        
        # Add frequency optimization for best parameters
        print("\nOptimizing trading frequency for best MA parameters...")
        freq_results = optimize_ma_frequency(df, {
            'Short_Window': int(best_ma['Short_Window']),
            'Long_Window': int(best_ma['Long_Window'])
        })
        
        if not freq_results.empty:
            best_freq_result = freq_results.loc[freq_results['Total_Return'].idxmax()]
            print("\nBest frequency results:")
            print(best_freq_result)
            
            # Update the best MA parameters with frequency-optimized version
            best_ma = best_freq_result
            
        # Generate trade list using best parameters
        best_ma_df = add_moving_averages(
            df_high.copy(), 
            int(best_ma['Short_Window']), 
            int(best_ma['Long_Window'])
        )
        best_ma_df = generate_ma_signals(best_ma_df)
        
        print("Best MA Crossover parameters:")
        print(best_ma)
        
        ma_trades = generate_trade_list(best_ma_df, 'MA')
        ma_trades.to_csv('ma_trades.csv', index=False)
        print("MA Crossover trades saved to 'ma_trades.csv'")

        strategy_dfs['MA'] = best_ma_df
        
        # Save frequency optimization results if available
        if 'freq_results' in locals() and not freq_results.empty:
            freq_results.to_csv('ma_frequency_optimization.csv', index=False)
            print("Frequency optimization results saved to 'ma_frequency_optimization.csv'")
            
        strategies['MA'] = best_ma.to_dict()
        all_results_list.append(ma_results)
    else:
        print("No MA Crossover strategies met the criteria.")

    ###########################################################################
    # If only_ma is True, then we skip all the other strategies below.
    ###########################################################################
    if not only_ma:
        # ----------------------------------------------------
        # RSI Strategy
        # ----------------------------------------------------
        print("Running RSI Strategy...")
        rsi_results = optimize_rsi_parameters(
            df_high,
            range(10, 21, 2),
            range(65, 81, 5),
            range(20, 36, 5),
            min_trades_per_day=min_trades_per_day,
            max_trades_per_day=max_trades_per_day,
            min_total_return=min_total_return,
            min_profit_per_trade=min_profit_per_trade
        )
        if not rsi_results.empty:
            best_rsi = rsi_results.loc[rsi_results['Total_Return'].idxmax()]
            print("Best RSI parameters:")
            print(best_rsi)
            strategies['RSI'] = best_rsi.to_dict()
            all_results_list.append(rsi_results)

            print("Generating trade list for best RSI strategy...")
            best_rsi_df = calculate_rsi(df_high.copy(), int(best_rsi['RSI_Window']))
            best_rsi_df = generate_rsi_signals(best_rsi_df,
                                               int(best_rsi['Overbought']),
                                               int(best_rsi['Oversold']))
            rsi_trades = generate_trade_list(best_rsi_df, 'RSI')
            rsi_trades.to_csv('rsi_trades.csv', index=False)
            print("RSI trades saved to 'rsi_trades.csv'")

            strategy_dfs['RSI'] = best_rsi_df
        else:
            print("No RSI strategies met the criteria.")

        # ----------------------------------------------------
        # Bollinger Bands Strategy
        # ----------------------------------------------------
        print("Running Bollinger Bands Strategy...")
        bb_param_grid = [{'window': w, 'num_std': s}
                         for w in range(10, 31, 5) for s in [1.5, 2, 2.5]]
        bb_results = optimize_hft_parameters(
            df_low,
            'BB',
            param_grid=bb_param_grid,
            min_trades_per_day=min_trades_per_day,
            max_trades_per_day=max_trades_per_day,
            min_total_return=min_total_return,
            min_profit_per_trade=min_profit_per_trade
        )
        if not bb_results.empty:
            best_bb = bb_results.loc[bb_results['Total_Return'].idxmax()]
            print("Best Bollinger Bands parameters:")
            print(best_bb)
            strategies['Bollinger Bands'] = best_bb.to_dict()
            all_results_list.append(bb_results)

            print("Generating trade list for best Bollinger Bands strategy...")
            best_bb_df = calculate_bollinger_bands(
                df_low.copy(),
                window=int(best_bb['window']),
                num_std=best_bb['num_std']
            )
            best_bb_df = generate_bollinger_band_signals(best_bb_df)
            bb_trades = generate_trade_list(best_bb_df, 'BB')
            bb_trades.to_csv('bb_trades.csv', index=False)
            print("Bollinger Bands trades saved to 'bb_trades.csv'")

            strategy_dfs['Bollinger Bands'] = best_bb_df
        else:
            print("No Bollinger Bands strategies met the criteria.")

        # ----------------------------------------------------
        # MACD Strategy
        # ----------------------------------------------------
        print("Running MACD Strategy...")
        macd_param_grid = [{'fast': f, 'slow': s, 'signal': sig}
                           for f in [6, 12, 18]
                           for s in [20, 26, 32]
                           for sig in [7, 9, 11]]
        macd_results = optimize_hft_parameters(
            df_low,
            'MACD',
            param_grid=macd_param_grid,
            min_trades_per_day=min_trades_per_day,
            max_trades_per_day=max_trades_per_day,
            min_total_return=min_total_return,
            min_profit_per_trade=min_profit_per_trade
        )
        if not macd_results.empty:
            best_macd = macd_results.loc[macd_results['Total_Return'].idxmax()]
            print("Best MACD parameters:")
            print(best_macd)
            strategies['MACD'] = best_macd.to_dict()
            all_results_list.append(macd_results)

            print("Generating trade list for best MACD strategy...")
            best_macd_df = calculate_macd(
                df_low.copy(),
                fast=int(best_macd['fast']),
                slow=int(best_macd['slow']),
                signal=int(best_macd['signal'])
            )
            best_macd_df = generate_macd_signals(best_macd_df)
            macd_trades = generate_trade_list(best_macd_df, 'MACD')
            macd_trades.to_csv('macd_trades.csv', index=False)
            print("MACD trades saved to 'macd_trades.csv'")

            strategy_dfs['MACD'] = best_macd_df
        else:
            print("No MACD strategies met the criteria.")

        # ----------------------------------------------------
        # RAMM Strategy
        # ----------------------------------------------------
        print("Running RAMM Strategy...")
        ramm_results = optimize_ramm_parameters(
            df_high,
            max_iterations=max_iterations,
            min_trades_per_day=min_trades_per_day,
            max_trades_per_day=max_trades_per_day,
            min_total_return=min_total_return,
            min_profit_per_trade=min_profit_per_trade
        )
        if not ramm_results.empty:
            best_ramm = ramm_results.loc[ramm_results['Total_Return'].idxmax()]
            print("Best RAMM parameters:")
            print(best_ramm)
            strategies['RAMM'] = best_ramm.to_dict()
            all_results_list.append(ramm_results)

            print("Generating trade list for best RAMM strategy...")
            best_ramm_df = calculate_ramm_signals(
                df_high.copy(),
                ma_short=int(best_ramm['MA_Short']),
                ma_long=int(best_ramm['MA_Long']),
                rsi_period=int(best_ramm['RSI_Period']),
                rsi_ob=int(best_ramm['RSI_Overbought']),
                rsi_os=int(best_ramm['RSI_Oversold']),
                regime_lookback=int(best_ramm['Regime_Lookback'])
            )
            ramm_trades = generate_trade_list(best_ramm_df, 'RAMM')
            ramm_trades.to_csv('ramm_trades.csv', index=False)
            print("RAMM trades saved to 'ramm_trades.csv'")

            strategy_dfs['RAMM'] = best_ramm_df
        else:
            print("No RAMM strategies met the criteria.")

        # ----------------------------------------------------
        # Adaptive VWMA Strategy
        # ----------------------------------------------------
        print("Running Adaptive VWMA Strategy...")
        adaptive_vwma_results = optimize_adaptive_vwma_parameters(
            df_high,
            min_trades_per_day=min_trades_per_day,
            max_trades_per_day=max_trades_per_day,
            min_total_return=min_total_return,
            min_profit_per_trade=min_profit_per_trade
        )
        if not adaptive_vwma_results.empty:
            best_adaptive_vwma = adaptive_vwma_results.loc[adaptive_vwma_results['Total_Return'].idxmax()]
            print("Best Adaptive VWMA parameters:")
            print(best_adaptive_vwma)
            strategies['Adaptive_VWMA'] = best_adaptive_vwma.to_dict()
            all_results_list.append(adaptive_vwma_results)

            print("Generating trade list for best Adaptive VWMA strategy...")
            best_adaptive_vwma_df = calculate_adaptive_vwma(
                df_high.copy(),
                base_window=int(best_adaptive_vwma['Base_Window'])
            )
            best_adaptive_vwma_df = generate_adaptive_vwma_signals(
                best_adaptive_vwma_df,
                vol_scale=best_adaptive_vwma['Volume_Scale']
            )
            adaptive_vwma_trades = generate_trade_list(best_adaptive_vwma_df, 'Adaptive_VWMA')
            adaptive_vwma_trades.to_csv('adaptive_vwma_trades.csv', index=False)
            print("Adaptive VWMA trades saved to 'adaptive_vwma_trades.csv'")

            strategy_dfs['Adaptive_VWMA'] = best_adaptive_vwma_df
        else:
            print("No Adaptive VWMA strategies met the criteria.")

    # -------------------------------------------------------------------------
    # Summaries & best-strategy logic remain the same
    # -------------------------------------------------------------------------
    if strategies:
        print("Preparing detailed strategy results...")
        print_strategy_results(strategies)

        print("\nStrategy Comparison:")
        comparison_df = pd.DataFrame.from_dict(strategies, orient='index')
        print(comparison_df)

        # Safely extract and compare total returns
        total_returns = {name: result.get('Total_Return', 0)
                         for name, result in strategies.items()}

        if total_returns:
            best_strategy = max(total_returns.items(), key=lambda x: x[1])[0]
            print(f"\nBest overall strategy: {best_strategy}")
            print(f"Best strategy Total Return: {total_returns[best_strategy]:.2f}%")

            # Save the best strategy parameters to a JSON file
            def convert_types(value):
                if isinstance(value, (np.integer, np.int64)):
                    return int(value)
                elif isinstance(value, (np.floating, np.float64)):
                    return float(value)
                elif isinstance(value, np.ndarray):
                    return value.tolist()
                elif isinstance(value, pd.Timestamp):
                    return value.isoformat()
                else:
                    return value

            best_strategy_params_converted = {
                key: convert_types(value) for key, value in strategies[best_strategy].items()
            }

            # Determine the last non-zero signal for the best strategy
            df_best = strategy_dfs.get(best_strategy, None)
            if df_best is not None:
                if best_strategy == "Bollinger Bands":
                    signal_col = "BB_Signal"
                else:
                    signal_col = f"{best_strategy}_Signal".replace(" ", "_")

                last_signals = df_best[df_best[signal_col] != 0]
                if not last_signals.empty:
                    last_row = last_signals.iloc[-1]
                    last_signal_value = last_row[signal_col]
                    best_strategy_params_converted["Last_Signal_Timestamp"] = int(last_row["timestamp"])
                    if last_signal_value == 1:
                        best_strategy_params_converted["Last_Signal_Action"] = "GO LONG"
                    else:
                        best_strategy_params_converted["Last_Signal_Action"] = "GO SHORT"
                else:
                    best_strategy_params_converted["Last_Signal_Timestamp"] = None
                    best_strategy_params_converted["Last_Signal_Action"] = None

            # Also store the last trade's timestamp and price
            if not df.empty:
                best_strategy_params_converted["Last_Trade_Timestamp"] = int(df['timestamp'].iloc[-1])
                best_strategy_params_converted["Last_Trade_Price"] = float(df['price'].iloc[-1])
            else:
                best_strategy_params_converted["Last_Trade_Timestamp"] = None
                best_strategy_params_converted["Last_Trade_Price"] = None

            # Ensure do_live_trades = false
            best_strategy_params_converted["do_live_trades"] = False

            try:
                with open('best_strategy.json', 'w') as f:
                    json.dump(best_strategy_params_converted, f, indent=4)
                print("\nBest strategy parameters saved to 'best_strategy.json'")
            except Exception as e:
                print("An error occurred while writing the best strategy parameters to 'best_strategy.json':")
                traceback.print_exc()

            # Write out a full trade list for the best strategy to best_strategy_trades.json
            if df_best is not None:
                # ADDED custom default function to handle pd.Timestamp
                def convert_timestamps_for_json(obj):
                    if isinstance(obj, pd.Timestamp):
                        return obj.isoformat()
                    return str(obj)

                try:
                    best_strategy_trades = generate_trade_list(df_best, best_strategy)
                    trades_records = best_strategy_trades.to_dict(orient='records')
                    # Pass our custom converter in 'json.dump'
                    with open('best_strategy_trades.json', 'w') as f:
                        json.dump(trades_records, f, indent=4, default=convert_timestamps_for_json)
                    print("\nAll trades for best strategy saved to 'best_strategy_trades.json'")
                except Exception as e:
                    print("An error occurred while writing best_strategy_trades.json:")
                    traceback.print_exc()

            print("\nAll strategy returns:")
            for strategy, t_ret in total_returns.items():
                print(f"{strategy}: {t_ret:.2f}%")
        else:
            print("\nNo strategies met the criteria.")

        if all_results_list:
            all_results = pd.concat(all_results_list, ignore_index=True)
            all_results.to_csv('optimization_results.csv', index=False)
            print("\nAll optimization results saved to 'optimization_results.csv'")
        else:
            print("\nNo optimization results to save.")
            all_results = pd.DataFrame()
    else:
        print("No strategies met the criteria. No comparison or results to display.")
        comparison_df = pd.DataFrame()
        all_results = pd.DataFrame()

    return all_results, comparison_df

--- END FILE: utils/analysis.py ---

--- BEGIN FILE: utils/helpers.py ---
# src/utils/helpers.py

import pandas as pd

def ensure_datetime_index(df):
    if 'datetime' not in df.columns:
        df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')
    if not isinstance(df.index, pd.DatetimeIndex):
        df.set_index('datetime', inplace=True)
    return df

def print_strategy_results(strategies):
    print("\nDetailed Strategy Results:")
    for name, result in strategies.items():
        print(f"{name}:")
        for key, value in result.items():
            print(f"{key}: {value}")
        print()

--- END FILE: utils/helpers.py ---


Here is the src/tdr.py app and dependencies:
./src
├── backtesting
│   ├── __init__.py
│   └── backtester.py
├── data
│   ├── __init__.py
│   └── loader.py
├── indicators
│   ├── __init__.py
│   └── technical_indicators.py
├── optimization
│   ├── __init__.py
│   └── optimizer.py
├── strategies
│   ├── __init__.py
│   └── ramm_strategy.py
├── tdr.py
├── tdr_core
│   ├── data_manager.py
│   ├── order_placer.py
│   ├── shell.py
│   ├── strategies.py
│   ├── trade.py
│   └── websocket_client.py
└── utils
    ├── __init__.py
    ├── analysis.py
    └── helpers.py

--- BEGIN FILE: backtesting/__init__.py ---
# src/backtesting/__init__.py

--- END FILE: backtesting/__init__.py ---

--- BEGIN FILE: backtesting/backtester.py ---
# src/backtesting/backtester.py

import pandas as pd
import numpy as np

from indicators.technical_indicators import ensure_datetime_index

def backtest(df, strategy, initial_balance=10000, position_size=0.1, transaction_cost=0.001, max_trades_per_day=10):
    df = ensure_datetime_index(df)
    df['Position'] = df[f'{strategy}_Signal'].shift(1).fillna(0)
    df['Returns'] = df['price'].pct_change().fillna(0)
    df['Strategy_Returns'] = df['Position'] * df['Returns']

    # Calculate transaction costs
    df['Trade'] = df['Position'].diff().abs()
    df['Transaction_Costs'] = df['Trade'] * transaction_cost

    # Limit trades per day
    df['Daily_Trades'] = df['Trade'].groupby(df.index.date).cumsum()
    df.loc[df['Daily_Trades'] > max_trades_per_day, 'Strategy_Returns'] = 0

    df['Strategy_Returns'] -= df['Transaction_Costs']
    df['Cumulative_Returns'] = (1 + df['Strategy_Returns']).cumprod()
    df['Balance'] = initial_balance * df['Cumulative_Returns']

    total_trades = df['Trade'].sum()

    # Calculate average trades per day
    from datetime import timedelta
    trading_days = (df.index[-1].date() - df.index[0].date()).days + 1
    average_trades_per_day = total_trades / trading_days if trading_days > 0 else 0

    # Profit factor and Sharpe ratio
    positive_returns = df.loc[df['Strategy_Returns'] > 0, 'Strategy_Returns'].sum()
    negative_returns = -df.loc[df['Strategy_Returns'] < 0, 'Strategy_Returns'].sum()
    profit_factor = positive_returns / negative_returns if negative_returns != 0 else np.inf

    sharpe_ratio = (df['Strategy_Returns'].mean() / df['Strategy_Returns'].std()) * np.sqrt(252) if df['Strategy_Returns'].std() != 0 else 0

    final_balance = df['Balance'].iloc[-1]
    total_return = (final_balance - initial_balance) / initial_balance * 100

    return {
        'Final_Balance': final_balance,
        'Total_Return': total_return,
        'Total_Trades': total_trades,
        'Average_Trades_Per_Day': average_trades_per_day,
        'Profit_Factor': profit_factor,
        'Sharpe_Ratio': sharpe_ratio
    }

def generate_trade_list(df, strategy):
    """
    Generate a list of all trades (long AND short) for the given strategy.

    Original logic only tracked long entries (signal==1) and exits (signal==-1),
    ignoring short trades. We have now expanded this to handle short entries and
    exits as well.

    The trades list will contain a dictionary for each completed trade:
    {
        'Entry Time': ...,
        'Exit Time': ...,
        'Entry Price': ...,
        'Exit Price': ...,
        'Profit (%)': ...
    }
    """
    trades = []
    position = 0
    entry_price = 0
    entry_time = None

    for index, row in df.iterrows():
        signal = row.get(f'{strategy}_Signal', 0)

        # ----------------------------
        # LONG ENTRY
        # ----------------------------
        if signal == 1 and position == 0:
            position = 1
            entry_price = row['price']
            entry_time = index
        
        # ----------------------------
        # LONG EXIT
        # ----------------------------
        elif signal == -1 and position == 1:
            exit_price = row['price']
            profit = (exit_price - entry_price) / entry_price
            trades.append({
                'Entry Time': entry_time,
                'Exit Time': index,
                'Entry Price': entry_price,
                'Exit Price': exit_price,
                'Profit (%)': profit * 100
            })
            position = 0

        # ----------------------------
        # SHORT ENTRY (ADDED)
        # ----------------------------
        elif signal == -1 and position == 0:
            # ADDED: logic for opening a short
            position = -1
            entry_price = row['price']
            entry_time = index

        # ----------------------------
        # SHORT EXIT (ADDED)
        # ----------------------------
        elif signal == 1 and position == -1:
            # ADDED: logic for closing a short
            exit_price = row['price']
            # profit for short is (Entry Price - Exit Price) / Entry Price
            profit = (entry_price - exit_price) / entry_price
            trades.append({
                'Entry Time': entry_time,
                'Exit Time': index,
                'Entry Price': entry_price,
                'Exit Price': exit_price,
                'Profit (%)': profit * 100
            })
            position = 0

    return pd.DataFrame(trades)

--- END FILE: backtesting/backtester.py ---

--- BEGIN FILE: data/__init__.py ---
# src/data/__init__.py

--- END FILE: data/__init__.py ---

--- BEGIN FILE: data/loader.py ---
# src/data/loader.py

import json
import os
import pandas as pd
from datetime import datetime

def create_metadata_file(log_file_path, metadata_file_path):
    print("Creating metadata file...")
    metadata = {}
    total_lines = 0
    last_timestamp = None

    with open(log_file_path, 'r') as file:
        for line in file:
            total_lines += 1
            if total_lines % 1000000 == 0:
                print(f"Processed {total_lines} lines...")
            try:
                json_data = json.loads(line)
                if json_data['event'] == 'trade':
                    timestamp = int(json_data['data']['timestamp'])
                    date = datetime.fromtimestamp(timestamp).date()
                    if str(date) not in metadata:
                        metadata[str(date)] = {
                            'start_line': total_lines, 'timestamp': timestamp}
                    last_timestamp = timestamp
            except json.JSONDecodeError:
                continue

    metadata['total_lines'] = total_lines
    metadata['last_timestamp'] = last_timestamp

    with open(metadata_file_path, 'w') as file:
        json.dump(metadata, file)

    print(f"Metadata file created: {metadata_file_path}")

def get_start_line_from_metadata(metadata_file_path, start_date):
    with open(metadata_file_path, 'r') as file:
        metadata = json.load(file)

    start_date_str = str(start_date.date())
    if start_date_str in metadata:
        return metadata[start_date_str]['start_line']
    else:
        # If exact date not found, find the nearest date
        dates = [datetime.strptime(date, '%Y-%m-%d').date() for date in metadata.keys()
                 if date != 'total_lines' and date != 'last_timestamp']
        nearest_date = min(dates, key=lambda x: abs(x - start_date.date()))
        return metadata[str(nearest_date)]['start_line']

def parse_log_file(file_path, start_date=None, end_date=None):
    metadata_file_path = f"{file_path}.metadata"
    if not os.path.exists(metadata_file_path):
        create_metadata_file(file_path, metadata_file_path)

    data = []
    with open(metadata_file_path, 'r') as file:
        metadata = json.load(file)

    total_lines = metadata['total_lines']
    print(f"Total lines in log file: {total_lines}")

    start_line = 1
    if start_date:
        start_line = get_start_line_from_metadata(
            metadata_file_path, start_date)
        print(
            f"Starting from line {start_line} based on start date {start_date}")

    last_date = None
    skipped_count = start_line - 1
    processed_count = 0
    end_reached = False
    # Only show 10 progress updates
    progress_interval = max(total_lines // 10, 1)

    with open(file_path, 'r') as file:
        for i, line in enumerate(file, 1):
            if i < start_line:
                continue

            if i % progress_interval == 0:  # Show progress every 10%
                print(
                    f"Progress: {i/total_lines*100:.1f}% - Last date: {last_date}")

            try:
                json_data = json.loads(line)
                if json_data['event'] == 'trade':
                    trade_data = json_data['data']
                    timestamp = int(trade_data['timestamp'])
                    trade_date = datetime.fromtimestamp(timestamp)
                    last_date = trade_date.strftime('%Y-%m-%d %H:%M:%S')

                    if end_date and trade_date > end_date:
                        end_reached = True
                        break

                    if start_date and trade_date < start_date:
                        skipped_count += 1
                        continue

                    processed_count += 1
                    data.append({
                        'timestamp': timestamp,
                        'price': float(trade_data['price']),
                        'amount': float(trade_data['amount']),
                        'type': int(trade_data['type'])
                    })
            except json.JSONDecodeError:
                continue

    print(f"\nFinished processing log file. Last date processed: {last_date}")
    print(f"Total entries skipped: {skipped_count}")
    print(f"Total entries processed: {processed_count}")
    if end_reached:
        print(f"Reached end date: {end_date}")
    print("Creating DataFrame...")
    df = pd.DataFrame(data)

    # Optimize data types
    df['price'] = pd.to_numeric(df['price'], downcast='float')
    df['amount'] = pd.to_numeric(df['amount'], downcast='float')
    df['type'] = df['type'].astype('int8')

    return df

--- END FILE: data/loader.py ---

--- BEGIN FILE: indicators/__init__.py ---
# src/indicators/__init__.py

--- END FILE: indicators/__init__.py ---

--- BEGIN FILE: indicators/technical_indicators.py ---
# src/indicators/technical_indicators.py

import pandas as pd
import numpy as np

def ensure_datetime_index(df):
    """
    Ensures that the DataFrame has a datetime index.
    Assumes that the DataFrame has a 'timestamp' column in UNIX epoch format.
    """
    if 'timestamp' not in df.columns:
        raise KeyError("The DataFrame must contain a 'timestamp' column.")
    
    # Create 'datetime' column if it doesn't exist
    if 'datetime' not in df.columns:
        df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')
    
    # Set 'datetime' as index if not already
    if not isinstance(df.index, pd.DatetimeIndex):
        df.set_index('datetime', inplace=True)
    
    # Retain the 'timestamp' column
    return df

def calculate_market_conditions(df, lookback_short=5, lookback_long=20, price_col='price'):
    """
    Calculate market conditions including regime, volatility state, and volume profile.
    """
    df = ensure_datetime_index(df)
    
    # Price movement and volatility
    df['returns'] = df[price_col].pct_change()
    df['volatility_short'] = df['returns'].rolling(window=lookback_short).std()
    df['volatility_long'] = df['returns'].rolling(window=lookback_long).std()
    df['volatility_ratio'] = df['volatility_short'] / df['volatility_long']
    
    # Volume profile
    df['volume_value'] = df[price_col] * df['volume']
    df['volume_sma'] = df['volume_value'].rolling(window=lookback_long).mean()
    df['volume_ratio'] = df['volume_value'] / df['volume_sma']
    
    # Trend strength
    df['price_sma_short'] = df[price_col].rolling(window=lookback_short).mean()
    df['price_sma_long'] = df[price_col].rolling(window=lookback_long).mean()
    df['trend_strength'] = (df['price_sma_short'] - df['price_sma_long']) / df['price_sma_long']
    
    # Regime classification
    df['regime'] = 0  # Default to neutral regime
    
    # Trending regime conditions
    trending_conditions = (
        (df['trend_strength'].abs() > df['trend_strength'].rolling(lookback_long).std()) &
        (df['volume_ratio'] > 1.0)
    )
    df.loc[trending_conditions, 'regime'] = 1
    
    # Volatile regime conditions
    volatile_conditions = (
        (df['volatility_ratio'] > 1.2) &
        (df['volume_ratio'] > 1.5)
    )
    df.loc[volatile_conditions, 'regime'] = 2
    
    # Range-bound regime conditions
    range_bound_conditions = (
        (df['volatility_ratio'] < 0.8) &
        (df['trend_strength'].abs() < df['trend_strength'].rolling(lookback_long).std() * 0.5)
    )
    df.loc[range_bound_conditions, 'regime'] = -1
    
    return df

def calculate_adaptive_vwma(df, base_window=10, price_col='price'):
    """
    Calculate VWMA with adaptive parameters based on market conditions.
    """
    df = ensure_datetime_index(df)
    
    # Calculate market conditions
    df = calculate_market_conditions(df, price_col=price_col)
    
    # Adaptive VWMA window based on regime
    df['adaptive_window'] = base_window
    df.loc[df['regime'] == 1, 'adaptive_window'] = base_window * 0.5  # Shorter in trending
    df.loc[df['regime'] == 2, 'adaptive_window'] = base_window * 0.3  # Shortest in volatile
    df.loc[df['regime'] == -1, 'adaptive_window'] = base_window * 1.5  # Longer in range-bound
    
    # Calculate adaptive VWMA
    df['vol_price'] = df[price_col] * df['volume']
    df['VWMA'] = np.nan

    # FIX to avoid SettingWithCopyWarning
    for i in range(len(df)):
        window_size = int(df['adaptive_window'].iloc[i])
        if i >= window_size:
            vol_price_sum = df['vol_price'].iloc[i-window_size+1:i+1].sum()
            volume_sum = df['volume'].iloc[i-window_size+1:i+1].sum()
            df.loc[df.index[i], 'VWMA'] = vol_price_sum / volume_sum if volume_sum != 0 else np.nan
        else:
            df.loc[df.index[i], 'VWMA'] = np.nan
    
    # Calculate additional signals
    df['VWMA_slope'] = df['VWMA'].pct_change(periods=3)
    df['price_to_vwma'] = df[price_col] / df['VWMA'] - 1
    
    return df

def generate_adaptive_vwma_signals(df, vol_scale=1.0):
    """
    Generate trading signals with regime-based adaptivity.
    """
    df['Adaptive_VWMA_Signal'] = 0
    
    # Base volume threshold varies by regime
    df['vol_threshold'] = 1.1  # Default
    df.loc[df['regime'] == 1, 'vol_threshold'] = 1.0  # Lower in trending
    df.loc[df['regime'] == 2, 'vol_threshold'] = 1.3  # Higher in volatile
    df.loc[df['regime'] == -1, 'vol_threshold'] = 1.2  # Moderate in range-bound
    
    # Adjust thresholds by scale parameter
    df['vol_threshold'] = df['vol_threshold'] * vol_scale
    
    # Generate signals based on regime
    for regime in [-1, 0, 1, 2]:
        regime_mask = df['regime'] == regime
        
        if regime == 1:  # Trending regime
            # More sensitive to crossovers, strong volume confirmation
            long_conditions = regime_mask & (
                (df['price'] > df['VWMA']) &
                (df['VWMA_slope'] > 0) &
                (df['volume_ratio'] > df['vol_threshold'])
            )
            short_conditions = regime_mask & (
                (df['price'] < df['VWMA']) &
                (df['VWMA_slope'] < 0) &
                (df['volume_ratio'] > df['vol_threshold'])
            )
            
        elif regime == 2:  # Volatile regime
            # Quick reversals, very strict volume confirmation
            long_conditions = regime_mask & (
                (df['price_to_vwma'] < -0.02) &
                (df['VWMA_slope'].shift(1) < 0) & (df['VWMA_slope'] > 0) &
                (df['volume_ratio'] > df['vol_threshold'])
            )
            short_conditions = regime_mask & (
                (df['price_to_vwma'] > 0.02) &
                (df['VWMA_slope'].shift(1) > 0) & (df['VWMA_slope'] < 0) &
                (df['volume_ratio'] > df['vol_threshold'])
            )
            
        elif regime == -1:  # Range-bound regime
            # Mean reversion signals
            long_conditions = regime_mask & (
                (df['price_to_vwma'] < -0.01) &
                (df['volume_ratio'] > df['vol_threshold']) &
                (df['volatility_ratio'] < 1.0)
            )
            short_conditions = regime_mask & (
                (df['price_to_vwma'] > 0.01) &
                (df['volume_ratio'] > df['vol_threshold']) &
                (df['volatility_ratio'] < 1.0)
            )
            
        else:  # Neutral regime
            # Conservative signals
            long_conditions = regime_mask & (
                (df['price'] > df['VWMA']) &
                (df['volume_ratio'] > df['vol_threshold']) &
                (df['VWMA_slope'] > 0)
            )
            short_conditions = regime_mask & (
                (df['price'] < df['VWMA']) &
                (df['volume_ratio'] > df['vol_threshold']) &
                (df['VWMA_slope'] < 0)
            )
        
        df.loc[long_conditions, 'Adaptive_VWMA_Signal'] = 1
        df.loc[short_conditions, 'Adaptive_VWMA_Signal'] = -1
    
    return df


def add_moving_averages(df, short_window, long_window, price_col='price'):
    """
    Adds short and long moving averages to the DataFrame with consistent column names.
    """
    df = ensure_datetime_index(df)
    
    df['Short_MA'] = df[price_col].rolling(window=short_window).mean()
    df['Long_MA'] = df[price_col].rolling(window=long_window).mean()
    
    return df

def generate_ma_signals(df):
    """
    Generates moving average crossover signals.
    """
    df['MA_Signal'] = 0
    df.loc[df['Short_MA'] > df['Long_MA'], 'MA_Signal'] = 1
    df.loc[df['Short_MA'] < df['Long_MA'], 'MA_Signal'] = -1
    return df

def calculate_rsi(df, window=14, price_col='price'):
    """
    Calculate the Relative Strength Index (RSI).
    """
    df = ensure_datetime_index(df)
    delta = df[price_col].diff()
    gain = (delta.clip(lower=0)).rolling(window=window).mean()
    loss = (-delta.clip(upper=0)).rolling(window=window).mean()
    rs = gain / loss
    df['RSI'] = 100 - (100 / (1 + rs))
    return df

def generate_rsi_signals(df, overbought=70, oversold=30):
    """
    Generate RSI-based trading signals.
    """
    df['RSI_Signal'] = 0
    df.loc[df['RSI'] < oversold, 'RSI_Signal'] = 1
    df.loc[df['RSI'] > overbought, 'RSI_Signal'] = -1
    return df

def calculate_bollinger_bands(df, window=20, num_std=2, price_col='price'):
    """
    Calculate Bollinger Bands.
    """
    df = ensure_datetime_index(df)
    df['BB_MA'] = df[price_col].rolling(window=window).mean()
    df['BB_STD'] = df[price_col].rolling(window=window).std()
    df['BB_Upper'] = df['BB_MA'] + (df['BB_STD'] * num_std)
    df['BB_Lower'] = df['BB_MA'] - (df['BB_STD'] * num_std)
    return df

def generate_bollinger_band_signals(df):
    """
    Generate Bollinger Bands-based trading signals.
    """
    df['BB_Signal'] = 0
    df.loc[df['price'] < df['BB_Lower'], 'BB_Signal'] = 1  # Buy signal
    df.loc[df['price'] > df['BB_Upper'], 'BB_Signal'] = -1  # Sell signal
    return df

def calculate_macd(df, fast=12, slow=26, signal=9, price_col='price'):
    """
    Calculate the Moving Average Convergence Divergence (MACD).
    """
    df = ensure_datetime_index(df)
    df['MACD_Fast'] = df[price_col].ewm(span=fast, adjust=False).mean()
    df['MACD_Slow'] = df[price_col].ewm(span=slow, adjust=False).mean()
    df['MACD'] = df['MACD_Fast'] - df['MACD_Slow']
    df['MACD_Signal_Line'] = df['MACD'].ewm(span=signal, adjust=False).mean()
    return df

def generate_macd_signals(df):
    """
    Generate MACD-based trading signals.
    """
    df['MACD_Signal'] = 0
    df.loc[df['MACD'] > df['MACD_Signal_Line'], 'MACD_Signal'] = 1
    df.loc[df['MACD'] < df['MACD_Signal_Line'], 'MACD_Signal'] = -1
    return df

--- END FILE: indicators/technical_indicators.py ---

--- BEGIN FILE: optimization/__init__.py ---
# src/optimization/__init__.py

--- END FILE: optimization/__init__.py ---

--- BEGIN FILE: optimization/optimizer.py ---
# src/optimization/optimizer.py

import pandas as pd
import numpy as np
import random
from tqdm import tqdm
from itertools import product

from backtesting.backtester import backtest
from indicators.technical_indicators import (
    calculate_adaptive_vwma,
    generate_adaptive_vwma_signals,
    add_moving_averages,
    generate_ma_signals,
    calculate_rsi,
    generate_rsi_signals,
    calculate_bollinger_bands,
    generate_bollinger_band_signals,
    calculate_macd,
    generate_macd_signals,
    ensure_datetime_index
)
from strategies.ramm_strategy import calculate_ramm_signals


###############################################################################
# CHANGED: added optional constraints to each function
###############################################################################
def optimize_adaptive_vwma_parameters(df,
                                      base_window_range=range(5, 21, 3),
                                      vol_scale_range=np.arange(0.8, 1.4, 0.1),
                                      min_trades_per_day=1,         # NEW
                                      max_trades_per_day=4,         # NEW
                                      min_total_return=0.0,         # NEW
                                      min_profit_per_trade=0.0      # NEW
                                      ):
    """
    Optimize Adaptive VWMA parameters
    """
    results = []
    total_combinations = len(base_window_range) * len(vol_scale_range)

    print(f"Testing {total_combinations} parameter combinations...")

    with tqdm(total=total_combinations, desc="Optimizing Adaptive VWMA Parameters") as pbar:
        for base_window in base_window_range:
            for vol_scale in vol_scale_range:
                df_test = df.copy()

                # Calculate adaptive VWMA
                df_test = calculate_adaptive_vwma(df_test, base_window=base_window)

                # Generate signals
                df_test = generate_adaptive_vwma_signals(df_test, vol_scale=vol_scale)

                # Run backtest
                metrics = backtest(df_test, 'Adaptive_VWMA')
                average_trades_per_day = metrics['Average_Trades_Per_Day']
                total_return = metrics['Total_Return']  # in percent
                total_trades = metrics['Total_Trades']

                # Compute optional profit-per-trade if needed
                if total_trades > 0:
                    profit_per_trade = (metrics['Final_Balance'] - 10000) / total_trades
                else:
                    profit_per_trade = 0

                if (min_trades_per_day <= average_trades_per_day <= max_trades_per_day and
                        total_return >= min_total_return and
                        profit_per_trade >= min_profit_per_trade):
                    results.append({
                        'Strategy': 'Adaptive_VWMA',
                        'Base_Window': base_window,
                        'Volume_Scale': vol_scale,
                        **metrics
                    })

                pbar.update(1)

    return pd.DataFrame(results)


def optimize_ramm_parameters(df, 
                             max_iterations=50,
                             min_trades_per_day=1,    # NEW
                             max_trades_per_day=4,    # NEW
                             min_total_return=0.0,    # NEW
                             min_profit_per_trade=0.0 # NEW
                             ):
    """
    Optimize RAMM strategy parameters using grid search
    """
    results = []

    # Define parameter ranges
    ma_short_range = range(4, 21, 2)
    ma_long_range = range(20, 51, 5)
    rsi_period_range = range(10, 21, 2)
    rsi_ob_range = range(65, 81, 5)
    rsi_os_range = range(20, 36, 5)
    regime_lookback_range = range(15, 31, 5)

    # Create parameter combinations
    param_combinations = list(product(
        ma_short_range, ma_long_range,
        rsi_period_range, rsi_ob_range, rsi_os_range,
        regime_lookback_range
    ))

    # Limit combinations if needed
    if len(param_combinations) > max_iterations:
        param_combinations = random.sample(param_combinations, max_iterations)

    for params in tqdm(param_combinations, desc="Optimizing RAMM Parameters"):
        ma_short, ma_long, rsi_period, rsi_ob, rsi_os, regime_lookback = params

        if ma_short >= ma_long or rsi_os >= rsi_ob:
            continue

        df_test = df.copy()
        df_test = calculate_ramm_signals(
            df_test, ma_short, ma_long,
            rsi_period, rsi_ob, rsi_os,
            regime_lookback
        )

        metrics = backtest(df_test, 'RAMM')
        average_trades_per_day = metrics['Average_Trades_Per_Day']
        total_return = metrics['Total_Return']
        total_trades = metrics['Total_Trades']

        if total_trades > 0:
            profit_per_trade = (metrics['Final_Balance'] - 10000) / total_trades
        else:
            profit_per_trade = 0

        if (min_trades_per_day <= average_trades_per_day <= max_trades_per_day and
                total_return >= min_total_return and
                profit_per_trade >= min_profit_per_trade):
            results.append({
                'Strategy': 'RAMM',
                'MA_Short': ma_short,
                'MA_Long': ma_long,
                'RSI_Period': rsi_period,
                'RSI_Overbought': rsi_ob,
                'RSI_Oversold': rsi_os,
                'Regime_Lookback': regime_lookback,
                **metrics
            })

    return pd.DataFrame(results)


def optimize_ma_parameters(df, short_range, long_range,
                           min_trades_per_day=1,    # NEW
                           max_trades_per_day=4,    # NEW
                           min_total_return=0.0,    # NEW
                           min_profit_per_trade=0.0 # NEW
                           ):
    results = []
    for short_window in short_range:
        for long_window in long_range:
            if short_window >= long_window:
                continue
            df_test = add_moving_averages(df.copy(), short_window, long_window)
            df_test = generate_ma_signals(df_test)
            metrics = backtest(df_test, 'MA')
            average_trades_per_day = metrics['Average_Trades_Per_Day']
            total_return = metrics['Total_Return']
            total_trades = metrics['Total_Trades']

            if total_trades > 0:
                profit_per_trade = (metrics['Final_Balance'] - 10000) / total_trades
            else:
                profit_per_trade = 0

            if (min_trades_per_day <= average_trades_per_day <= max_trades_per_day and
                    total_return >= min_total_return and
                    profit_per_trade >= min_profit_per_trade):
                results.append({
                    'Strategy': 'MA',
                    'Short_Window': short_window,
                    'Long_Window': long_window,
                    **metrics
                })
    return pd.DataFrame(results)


def optimize_rsi_parameters(df, window_range, overbought_range, oversold_range,
                            min_trades_per_day=1,    # NEW
                            max_trades_per_day=4,    # NEW
                            min_total_return=0.0,    # NEW
                            min_profit_per_trade=0.0 # NEW
                            ):
    results = []
    for window in window_range:
        for overbought in overbought_range:
            for oversold in oversold_range:
                if oversold >= overbought:
                    continue
                df_test = calculate_rsi(df.copy(), window)
                df_test = generate_rsi_signals(df_test, overbought, oversold)
                metrics = backtest(df_test, 'RSI')
                average_trades_per_day = metrics['Average_Trades_Per_Day']
                total_return = metrics['Total_Return']
                total_trades = metrics['Total_Trades']

                if total_trades > 0:
                    profit_per_trade = (metrics['Final_Balance'] - 10000) / total_trades
                else:
                    profit_per_trade = 0

                if (min_trades_per_day <= average_trades_per_day <= max_trades_per_day and
                        total_return >= min_total_return and
                        profit_per_trade >= min_profit_per_trade):
                    results.append({
                        'Strategy': 'RSI',
                        'RSI_Window': window,
                        'Overbought': overbought,
                        'Oversold': oversold,
                        **metrics
                    })
    return pd.DataFrame(results)


def optimize_hft_parameters(df, strategy, param_grid,
                            min_trades_per_day=1,    # NEW
                            max_trades_per_day=4,    # NEW
                            min_total_return=0.0,    # NEW
                            min_profit_per_trade=0.0 # NEW
                            ):
    results = []
    for params in param_grid:
        df_test = df.copy()
        if strategy == 'BB':
            df_test = calculate_bollinger_bands(
                df_test, window=params['window'], num_std=params['num_std'])
            df_test = generate_bollinger_band_signals(df_test)
        elif strategy == 'MACD':
            df_test = calculate_macd(
                df_test, fast=params['fast'], slow=params['slow'], signal=params['signal'])
            df_test = generate_macd_signals(df_test)
        else:
            continue  # Skip if strategy not recognized

        metrics = backtest(df_test, strategy)
        average_trades_per_day = metrics['Average_Trades_Per_Day']
        total_return = metrics['Total_Return']
        total_trades = metrics['Total_Trades']

        if total_trades > 0:
            profit_per_trade = (metrics['Final_Balance'] - 10000) / total_trades
        else:
            profit_per_trade = 0

        if (min_trades_per_day <= average_trades_per_day <= max_trades_per_day and
                total_return >= min_total_return and
                profit_per_trade >= min_profit_per_trade):
            results.append({
                'Strategy': strategy,
                **params,
                **metrics
            })
    return pd.DataFrame(results)


def optimize_ma_frequency(df, base_parameters):
    """
    Optimize trading frequency for a given MA strategy configuration.

    Args:
        df: DataFrame with price data
        base_parameters: Dict containing 'Short_Window' and 'Long_Window'

    Returns:
        pd.DataFrame: Results of frequency optimization
    """
    frequencies = ['5min', '15min', '30min',
                   '1H', '2H', '4H', '6H', '12H', '1D']
    results = []

    print(f"Testing {len(frequencies)} different frequencies...")

    # Debug prints to inspect DataFrame structure before testing frequencies
    print("Debug: Columns available in DataFrame before frequency tests:", df.columns)
    print("Debug: DataFrame index type:", df.index)

    from tqdm import tqdm  # Already imported at top, but just ensuring
    with tqdm(total=len(frequencies), desc="Optimizing Trading Frequency") as pbar:
        for freq in frequencies:
            # Resample data to current frequency
            df_resampled = df.resample(freq).agg({
                'price': 'last',
                'amount': 'sum',
                'volume': 'sum'
            }).dropna()

            print(
                f"Debug after resampling at frequency {freq}: columns={df_resampled.columns}")

            # Restore timestamp column
            df_resampled['timestamp'] = df_resampled.index

            # Run strategy with base parameters
            df_strategy = add_moving_averages(
                df_resampled.copy(),
                short_window=base_parameters['Short_Window'],
                long_window=base_parameters['Long_Window'],
                price_col='price'
            )
            df_strategy = generate_ma_signals(df_strategy)

            # Run backtest
            metrics = backtest(df_strategy, 'MA')
            average_trades_per_day = metrics['Average_Trades_Per_Day']

            if 1 <= average_trades_per_day <= 4 and metrics['Total_Return'] > 0:
                results.append({
                    'Frequency': freq,
                    'Strategy': 'MA',
                    'Short_Window': base_parameters['Short_Window'],
                    'Long_Window': base_parameters['Long_Window'],
                    **metrics
                })

            pbar.update(1)

    return pd.DataFrame(results)

--- END FILE: optimization/optimizer.py ---

--- BEGIN FILE: strategies/__init__.py ---
# src/strategies/__init__.py

--- END FILE: strategies/__init__.py ---

--- BEGIN FILE: strategies/ramm_strategy.py ---
# src/strategies/ramm_strategy.py

from indicators.technical_indicators import (
    ensure_datetime_index,
    add_moving_averages,
    calculate_rsi,
    calculate_market_conditions
)

def calculate_ramm_signals(df,
                           ma_short=10, ma_long=50,  # MA parameters
                           rsi_period=14, rsi_ob=70, rsi_os=30,  # RSI parameters
                           regime_lookback=20):
    """
    Generate RAMM strategy signals combining MA Crossover and RSI based on market regime
    """
    df = ensure_datetime_index(df)

    # Calculate market regime
    df_regime = calculate_market_conditions(df.copy(), regime_lookback)
    df['regime'] = df_regime['regime']

    # Calculate MA signals
    df = add_moving_averages(df, ma_short, ma_long)
    df['MA_Signal'] = 0
    df.loc[df['Short_MA'] > df['Long_MA'], 'MA_Signal'] = 1
    df.loc[df['Short_MA'] < df['Long_MA'], 'MA_Signal'] = -1

    # Calculate RSI signals
    df = calculate_rsi(df, rsi_period)
    df['RSI_Signal'] = 0
    df.loc[df['RSI'] < rsi_os, 'RSI_Signal'] = 1
    df.loc[df['RSI'] > rsi_ob, 'RSI_Signal'] = -1

    # Generate RAMM signals based on regime
    df['RAMM_Signal'] = 0

    # Trending regime: use MA Crossover
    df.loc[df['regime'] == 1, 'RAMM_Signal'] = df.loc[df['regime'] == 1, 'MA_Signal']

    # Mean-reverting regime: use RSI
    df.loc[df['regime'] == -1, 'RAMM_Signal'] = df.loc[df['regime'] == -1, 'RSI_Signal']

    # Mixed regime: combine signals (only take trades when both agree)
    mixed_mask = df['regime'] == 0
    df.loc[mixed_mask & (df['MA_Signal'] == 1) & (df['RSI_Signal'] == 1), 'RAMM_Signal'] = 1
    df.loc[mixed_mask & (df['MA_Signal'] == -1) & (df['RSI_Signal'] == -1), 'RAMM_Signal'] = -1

    return df

--- END FILE: strategies/ramm_strategy.py ---

--- BEGIN FILE: tdr.py ---
###############################################################################
# src/tdr.py
###############################################################################
# Full File Path: src/tdr.py
#
# CHANGES (EXPLANATION):
#   1) We introduce RSI auto-trading support so that best_strategy.json 
#      with "Strategy": "RSI" can be used by the "auto_trade" command.
#   2) We preserve all existing comments, logic, and code related to the 
#      MA strategy. We only add new logic in do_auto_trade to handle RSI.
#   3) For consistency, we read "RSI_Window", "Overbought", "Oversold" 
#      from best_strategy.json, and construct an RSITradingStrategy 
#      (see the newly added RSITradingStrategy class in tdr_core/strategies.py).
#   4) We keep the original references to "MACrossoverStrategy" for "MA" 
#      and only add an elif block if "Strategy" == "RSI".
#   5) All original code, comments, and structure remain intact; 
#      only minimal changes appear for RSI integration.
#
# NOTE: You must also see the changes in src/tdr_core/strategies.py 
#       (shown below) for the RSITradingStrategy class. If that file 
#       is missing or out-of-date, please request the updated version.
###############################################################################

#!/usr/bin/env python
# src/tdr.py

import sys
import os
import pandas as pd
import numpy as np
import asyncio
import websockets
import json
import time
import logging
import threading
from datetime import datetime, timedelta
from multiprocessing import Process, Manager, set_start_method

# For the Plotly and Dash implementation
try:
    import dash
    from dash import dcc, html
    from dash.dependencies import Output, Input
    import plotly.graph_objs as go
except ImportError:
    pass  # We will handle the ImportError in the do_chart method

# Adjust sys.path to import modules from 'src' directory
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(parent_dir)
sys.path.append(current_dir)

# Import parse_log_file from data.loader
from data.loader import parse_log_file

# Import indicators/technical_indicators
from indicators.technical_indicators import (
    ensure_datetime_index,
    add_moving_averages,
    generate_ma_signals,
    calculate_rsi,
    generate_rsi_signals,
    calculate_bollinger_bands,
    generate_bollinger_band_signals,
    calculate_macd,
    generate_macd_signals,
)

# ------------------------------------------------------------------------
# NEW IMPORTS for refactored modules (preserving original classes/functions)
# ------------------------------------------------------------------------
from tdr_core.data_manager import CryptoDataManager
from tdr_core.trade import Trade
from tdr_core.websocket_client import subscribe_to_websocket
from tdr_core.order_placer import OrderPlacer
from tdr_core.strategies import MACrossoverStrategy, RSITradingStrategy  # ADDED RSITradingStrategy
from tdr_core.shell import CryptoShell

HIGH_FREQUENCY = '1H'  # Default bar size
STALE_FEED_SECONDS = 120  # If more than 2 minutes pass with no trades, attempt reconnect.


def determine_initial_position(df: pd.DataFrame, short_window: int, long_window: int) -> int:
    """
    Computes the final short/long MA crossover on df to decide 
    if we "should" be long (1), short (-1), or neutral (0).
    """
    if len(df) < long_window:
        return 0
    df_copy = ensure_datetime_index(df.copy())
    df_copy['Short_MA'] = df_copy['close'].rolling(short_window).mean()
    df_copy['Long_MA'] = df_copy['close'].rolling(long_window).mean()
    df_copy.dropna(inplace=True)
    if df_copy.empty:
        return 0
    last_short = df_copy.iloc[-1]['Short_MA']
    last_long  = df_copy.iloc[-1]['Long_MA']
    if last_short > last_long:
        return 1
    elif last_short < last_long:
        return -1
    else:
        return 0


def run_websocket(url, symbols, data_manager, stop_event):
    """
    Launch a separate event loop to handle multiple subscribe tasks,
    including staleness detection.
    """
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    tasks = [subscribe_to_websocket(url, symbol, data_manager, stop_event) for symbol in symbols]

    async def main():
        await asyncio.gather(*tasks)

    try:
        loop.run_until_complete(main())
    except Exception as e:
        data_manager.logger.error(f"WebSocket encountered error: {e}")
    finally:
        loop.close()


def setup_logging(verbose):
    logger = logging.getLogger("CryptoShellLogger")
    logger.setLevel(logging.DEBUG if verbose else logging.INFO)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')

    stream_handler = logging.StreamHandler(sys.stdout)
    stream_handler.setLevel(logging.INFO)
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)

    file_handler = logging.FileHandler('crypto_shell.log')
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    return logger


def main():
    """
    Main entry point: reads best_strategy.json for config, 
    parses historical log if present, then launches the CryptoShell.
    """
    config_file = os.path.abspath("best_strategy.json")
    if not os.path.exists(config_file):
        print(f"No '{config_file}' found. Using default settings.")
        config = {}
    else:
        with open(config_file, 'r') as f:
            config = json.load(f)

    start_back = config.get('start_window_days_back', 30)
    end_back   = config.get('end_window_days_back', 0)
    do_live    = config.get('do_live_trades', False)
    max_trades = config.get('max_trades_per_day', 5)

    now = datetime.now()
    start_date = now - timedelta(days=start_back) if start_back else None
    end_date   = now - timedelta(days=end_back) if end_back else None

    if start_date and end_date and start_date >= end_date:
        print("Invalid date range from best_strategy.json; ignoring end_date.")
        end_date = None

    logger = setup_logging(verbose=False)
    if do_live:
        logger.info("Running in LIVE trading mode.")
    else:
        logger.info("Running in DRY RUN mode.")

    log_file_path = os.path.abspath("btcusd.log")
    if not os.path.exists(log_file_path):
        print(f"No local log file '{log_file_path}'. Relying on real-time data only.")
        df = pd.DataFrame()
    else:
        df = parse_log_file(log_file_path, start_date, end_date)

    if not df.empty:
        df.rename(columns={'price': 'close'}, inplace=True)
        df['open'] = df['close']
        df['high'] = df['close']
        df['low'] = df['close']
        df['trades'] = 1
        if 'volume' not in df.columns:
            df['volume'] = df.get('amount', 0.0)

    data_manager = CryptoDataManager(["btcusd"], logger=logger)
    if not df.empty:
        data_manager.load_historical_data({'btcusd': df})

    order_placer = OrderPlacer()
    data_manager.order_placer = order_placer

    stop_event = threading.Event()
    shell = CryptoShell(
        data_manager=data_manager,
        order_placer=order_placer,
        logger=logger,
        verbose=False,
        live_trading=do_live,
        stop_event=stop_event,
        max_trades_per_day=max_trades
    )

    url = 'wss://ws.bitstamp.net'
    websocket_thread = threading.Thread(
        target=run_websocket, args=(url, ["btcusd"], data_manager, stop_event), daemon=True)
    websocket_thread.start()
    logger.debug("WebSocket thread started.")

    try:
        shell.cmdloop()
    except KeyboardInterrupt:
        print("\nInterrupted. Exiting gracefully.")
        shell.do_quit(None)
    finally:
        stop_event.set()
        if websocket_thread.is_alive():
            websocket_thread.join()
        if shell.auto_trader and shell.auto_trader.running:
            shell.auto_trader.stop()
        if shell.chart_process and shell.chart_process.is_alive():
            shell.stop_dash_app()


if __name__ == '__main__':
    set_start_method('spawn')
    main()

--- END FILE: tdr.py ---

--- BEGIN FILE: tdr_core/data_manager.py ---
# src/tdr_core/data_manager.py

import pandas as pd
import logging
import threading
from datetime import datetime, timedelta

from indicators.technical_indicators import ensure_datetime_index

###############################################################################
# CryptoDataManager
###############################################################################
class CryptoDataManager:
    """
    Stores and manages trade data and candle data for both historical and live data.
    """
    def __init__(self, symbols, logger, verbose=False):
        self.data = {
            symbol: pd.DataFrame(
                columns=['timestamp', 'open', 'high', 'low', 'close', 'volume', 'trades']
            ) for symbol in symbols
        }
        self.candlesticks = {symbol: {} for symbol in symbols}
        self.candlestick_observers = []
        self.trade_observers = []
        self.logger = logger
        self.verbose = verbose

        # Will hold the most recent "close" price
        self.last_price = {symbol: None for symbol in symbols}
        self.order_placer = None
        self.last_trade = {symbol: None for symbol in symbols}
        self.next_trigger = {symbol: None for symbol in symbols}
        self.current_trends = {symbol: {} for symbol in symbols}

        # For staleness detection: track last trade time
        self.last_trade_time = {symbol: None for symbol in symbols}

    def load_historical_data(self, data_dict):
        """
        Load historical data for each symbol from a dictionary of DataFrames.
        """
        total_symbols = len(data_dict)
        for idx, (symbol, df) in enumerate(data_dict.items(), 1):
            self.data[symbol] = df.reset_index(drop=True)
            if not df.empty:
                self.last_price[symbol] = df.iloc[-1]['close']
                self.logger.debug(
                    f"Loaded historical data for {symbol}, last price: {self.last_price[symbol]}"
                )
            print(f"Loaded historical data for {symbol} ({idx}/{total_symbols})")

    def add_candlestick_observer(self, callback):
        """
        Register a callback for candlestick updates.
        """
        self.candlestick_observers.append(callback)

    def add_trade_observer(self, callback):
        """
        Register a callback for trade updates.
        """
        self.trade_observers.append(callback)

    def set_verbose(self, verbose):
        self.verbose = verbose

    def add_trade(self, symbol, price, timestamp, trade_reason="Live Trade"):
        """
        Add a new trade to the candlestick data.
        Aggregates trades into current-minute candles.
        """
        price = float(price)
        dt = datetime.fromtimestamp(timestamp)
        minute = dt.replace(second=0, microsecond=0)

        if symbol not in self.candlesticks:
            self.candlesticks[symbol] = {}

        if minute not in self.candlesticks[symbol]:
            self.candlesticks[symbol][minute] = {
                'timestamp': int(minute.timestamp()),
                'open': price,
                'high': price,
                'low': price,
                'close': price,
                'volume': 0.0,
                'trades': 1
            }
        else:
            candle = self.candlesticks[symbol][minute]
            candle['high'] = max(candle['high'], price)
            candle['low'] = min(candle['low'], price)
            candle['close'] = price
            candle['trades'] += 1

        # Update last price and trade time
        self.last_price[symbol] = price
        self.last_trade_time[symbol] = dt

        # Notify trade observers
        for observer in self.trade_observers:
            observer(symbol, price, timestamp, trade_reason)

    def get_current_price(self, symbol):
        """
        Return the *most recent* known price (live trades if available).
        """
        if self.last_price[symbol] is not None:
            return self.last_price[symbol]

        if not self.data[symbol].empty:
            return self.data[symbol].iloc[-1]['close']
        return None

    def get_price_range(self, symbol, minutes):
        """
        Return the min and max price in the last 'minutes' of data.
        """
        now = pd.Timestamp.now()
        start_time = now - pd.Timedelta(minutes=minutes)
        df = self.data[symbol]
        mask = df['timestamp'] >= int(start_time.timestamp())
        relevant_data = df.loc[mask, 'close']
        if not relevant_data.empty:
            return relevant_data.min(), relevant_data.max()
        return None, None

    def get_price_dataframe(self, symbol):
        """
        Combine historical data with live candlesticks for a given symbol.
        """
        df = self.data[symbol].copy()
        if not df.empty:
            df['source'] = 'historical'
        else:
            df['source'] = pd.Series(dtype=str)

        if symbol in self.candlesticks:
            live_df = pd.DataFrame.from_dict(self.candlesticks[symbol], orient='index')
            live_df.sort_index(inplace=True)
            live_df['source'] = 'live'
            df = pd.concat([df, live_df], ignore_index=True)
            df.drop_duplicates(subset='timestamp', keep='last', inplace=True)
            df.sort_values('timestamp', inplace=True)
            df.reset_index(drop=True, inplace=True)

        return df

    def get_data_point_count(self, symbol):
        """
        Return the total count of data points stored for a given symbol.
        """
        return len(self.data[symbol])

--- END FILE: tdr_core/data_manager.py ---

--- BEGIN FILE: tdr_core/order_placer.py ---
# src/tdr_core/order_placer.py

import os
import json
import logging

###############################################################################
class OrderPlacer:
    """
    Handles order placement with the exchange (e.g. Bitstamp).
    """
    def __init__(self, config_file='.bitstamp'):
        self.config_file = config_file
        self.config = self.read_config(self.config_file)
        self.api_key = self.config['api_key']
        self.api_secret = bytes(self.config['api_secret'], 'utf-8')

    def read_config(self, file_name):
        file_path = os.path.abspath(file_name)
        try:
            with open(file_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            raise Exception(f"Failed to read config file '{file_name}': {e}")

    def place_order(self, order_type, currency_pair, amount, price=None, **kwargs):
        import time
        import uuid
        import hmac
        import hashlib
        from urllib.parse import urlencode
        import requests

        timestamp = str(int(round(time.time() * 1000)))
        nonce = str(uuid.uuid4())
        content_type = 'application/x-www-form-urlencoded'

        amount_rounded = round(amount, 8)
        payload = {'amount': str(amount_rounded)}
        if price:
            payload['price'] = str(price)

        for key, value in kwargs.items():
            if value is not None:
                payload[key] = str(value).lower() if isinstance(value, bool) else str(value)

        if 'market' in order_type:
            endpoint = f"/api/v2/{'buy' if 'buy' in order_type else 'sell'}/market/{currency_pair}/"
        else:
            endpoint = f"/api/v2/{'buy' if 'buy' in order_type else 'sell'}/{currency_pair}/"

        payload_string = urlencode(payload)
        message = (
            f"BITSTAMP {self.api_key}"
            f"POSTwww.bitstamp.net{endpoint}{content_type}{nonce}{timestamp}v2{payload_string}"
        )
        signature = hmac.new(self.api_secret, msg=message.encode('utf-8'), digestmod=hashlib.sha256).hexdigest()

        headers = {
            'X-Auth': f'BITSTAMP {self.api_key}',
            'X-Auth-Signature': signature,
            'X-Auth-Nonce': nonce,
            'X-Auth-Timestamp': timestamp,
            'X-Auth-Version': 'v2',
            'Content-Type': content_type
        }

        logging.info(f"Request Method: POST")
        logging.info(f"Request URL: https://www.bitstamp.net{endpoint}")
        logging.info(f"Request Headers: {headers}")
        logging.info(f"Request Payload: {payload_string}")

        url = f"https://www.bitstamp.net{endpoint}"
        r = requests.post(url, headers=headers, data=payload_string)
        if r.status_code == 200:
            return json.loads(r.content.decode('utf-8'))
        else:
            logging.error(f"Error placing order: {r.status_code} - {r.text}")
            return {"status": "error", "reason": r.text, "code": "API_FAILURE"}

    def place_limit_buy_order(self, currency_pair, amount, price, **kwargs):
        return self.place_order('buy', currency_pair, amount, price, **kwargs)

    def place_limit_sell_order(self, currency_pair, amount, price, **kwargs):
        return self.place_order('sell', currency_pair, amount, price, **kwargs)

--- END FILE: tdr_core/order_placer.py ---

--- BEGIN FILE: tdr_core/shell.py ---
###############################################################################
# src/tdr_core/shell.py
###############################################################################
# Full File Path: src/tdr_core/shell.py
#
# CHANGES (EXPLANATION):
#   1) When the user does "auto_trade <X>usd short", but we skip the forced 
#      SELL because "we have no BTC" (i.e. user_has_btc() == False), we now 
#      set a "theoretical short" entry price anyway. This helps the user see 
#      in 'status' that they are "short" with some cost basis, even though no 
#      real immediate trade was placed. 
#   2) This matches the user request: "Please note how I had asked that you set 
#      the entry price ... if we were already in the correct direction or 
#      skipping the forced SELL. Then show that in status as a 'theoretical' trade."
#   3) We only do this in the RSI and MA blocks if desired_position == -1 but 
#      we skip forcing the SELL due to zero local BTC. Then we do: 
#         position_size = - short_btc
#         position_cost_basis = short_btc * current_market_price
#         theoretical_trade dict
#      so that the "Entry Price" and "Short Size" appear in status.
#   4) All existing logic, commands, docstrings remain intact. We just add 
#      a snippet after we skip the forced SELL to set that "theoretical short." 
###############################################################################

import cmd
import sys
import json
import time
import logging
import threading
import requests
import os
from datetime import datetime
from flask import Flask, request
from multiprocessing import Process, Manager

# We'll need references to modules from our codebase:
from tdr_core.order_placer import OrderPlacer
from tdr_core.strategies import MACrossoverStrategy, RSITradingStrategy
from tdr_core.data_manager import CryptoDataManager
from tdr_core.trade import Trade

# Original references from tdr.py
from utils.analysis import analyze_data, run_trading_system
from data.loader import create_metadata_file, parse_log_file


def determine_rsi_position(df, rsi_window=14, overbought=70, oversold=30):
    """
    A minimal function to guess the final RSI-based position from the last row 
    of DF. If RSI < oversold => position=1, if RSI > overbought => position=-1, 
    else 0.

    This logic ensures that if we are already 'long' (1) or 'short' (-1) 
    per the last RSI signal, we skip forcing an immediate trade if the user 
    also chooses the same position. This covers both short->short and long->long.
    """
    if df.empty or len(df) < rsi_window:
        return 0
    from indicators.technical_indicators import ensure_datetime_index, calculate_rsi
    df_copy = ensure_datetime_index(df.copy())
    df_copy = df_copy.resample('1H').agg({
        'open': 'first',
        'high': 'max',
        'low': 'min',
        'close': 'last',
        'volume': 'sum',
        'trades': 'sum',
        'timestamp': 'last'
    }).dropna()
    if len(df_copy) < rsi_window:
        return 0

    df_copy = calculate_rsi(df_copy, window=rsi_window, price_col='close')
    last_rsi = df_copy.iloc[-1]['RSI']
    if last_rsi < oversold:
        return 1
    elif last_rsi > overbought:
        return -1
    return 0


###############################################################################
class CryptoShell(cmd.Cmd):
    """
    An interactive command-based shell for controlling the Crypto trading system.
    """
    intro = 'Welcome to the Crypto Shell (No CLI args). Type help or ? to list commands.\n'
    prompt = '(crypto) '

    def __init__(self, data_manager, order_placer, logger,
                 verbose=False, live_trading=False, stop_event=None,
                 max_trades_per_day=5):
        super().__init__()
        self.data_manager = data_manager
        self.order_placer = order_placer
        self.data_manager.order_placer = order_placer
        self.logger = logger
        self.candlestick_output = {}
        self.ticker_output = {}
        self.verbose = verbose
        self.live_trading = live_trading
        self.auto_trader = None
        self.chart_process = None
        self.stop_event = stop_event
        self.manager = Manager()
        self.data_manager_dict = self.manager.dict()
        self.max_trades_per_day = max_trades_per_day

        self.examples = {
            'price': 'price btcusd',
            'range': 'range btcusd 30',
            'buy': 'buy btcusd 0.001',
            'sell': 'sell btcusd 0.001',
            'candles': 'candles btcusd',
            'ticker': 'ticker btcusd',
            'example': 'example price',
            'limit_buy': 'limit_buy btcusd 0.001 50000 daily_order=true',
            'limit_sell': 'limit_sell btcusd 0.001 60000 ioc_order=true',
            'auto_trade': 'auto_trade 2.47btc long',
            'stop_auto_trade': 'stop_auto_trade',
            'status': 'status [long]',
            'chart': 'chart btcusd 1H'
        }

        # Register callbacks
        self.data_manager.add_candlestick_observer(self.candlestick_callback)
        self.data_manager.add_trade_observer(self.trade_callback)

    def emptyline(self):
        pass

    def do_example(self, arg):
        """
        Show an example usage of a command: example <command>
        """
        command = arg.strip().lower()
        if command in self.examples:
            print("Example usage of '{}':".format(command))
            print("  {}".format(self.examples[command]))
        else:
            print("No example for '{}'. Available commands:".format(command))
            print(", ".join(self.examples.keys()))

    def do_price(self, arg):
        """
        Show current price for a symbol, plus the last WebSocket update timestamp:
          price <symbol>
        """
        symbol = arg.strip().lower()
        if not symbol:
            print("Usage: price <symbol>")
            return
        price = self.data_manager.get_current_price(symbol)
        if price is not None:
            last_update_time = self.data_manager.last_trade_time.get(symbol)
            if last_update_time:
                update_str = last_update_time.strftime('%Y-%m-%d %H:%M:%S')
            else:
                update_str = "unknown (no trades yet)"
            print(f"Current price of {symbol}: ${price:.2f} (last update: {update_str})")
        else:
            print(f"No data for {symbol}")

    def do_range(self, arg):
        """
        Show min and max price in last N minutes: range <symbol> <minutes>
        """
        args = arg.split()
        if len(args) != 2:
            print("Usage: range <symbol> <minutes>")
            return
        symbol, minutes = args[0].lower(), int(args[1])
        min_price, max_price = self.data_manager.get_price_range(symbol, minutes)
        if min_price is not None and max_price is not None:
            print(f"Price range for {symbol} over last {minutes} minutes:")
            print(f"Min: ${min_price:.2f}, Max: ${max_price:.2f}")
        else:
            print(f"No data for {symbol} in that timeframe")

    def do_buy(self, arg):
        """
        Place a market buy order: buy <symbol> <amount>
        """
        args = arg.split()
        if len(args) != 2:
            print("Usage: buy <symbol> <amount>")
            return
        symbol, amount = args[0].lower(), float(args[1])
        result = self.order_placer.place_order("market-buy", symbol, amount)
        print(json.dumps(result, indent=2))

    def do_sell(self, arg):
        """
        Place a market sell order: sell <symbol> <amount>
        """
        args = arg.split()
        if len(args) != 2:
            print("Usage: sell <symbol> <amount>")
            return
        symbol, amount = args[0].lower(), float(args[1])
        result = self.order_placer.place_order("market-sell", symbol, amount)
        print(json.dumps(result, indent=2))

    def do_candles(self, arg):
        """
        Toggle 1-minute candlestick printout: candles <symbol>
        """
        symbol = arg.strip().lower()
        if not symbol:
            print("Usage: candles <symbol>")
            return
        if symbol in self.candlestick_output:
            del self.candlestick_output[symbol]
            print(f"Stopped 1-minute candlestick output for {symbol}")
        else:
            self.candlestick_output[symbol] = True
            print(f"Started 1-minute candlestick output for {symbol}")

    def do_ticker(self, arg):
        """
        Toggle real-time trade output: ticker <symbol>
        """
        symbol = arg.strip().lower()
        if not symbol:
            print("Usage: ticker <symbol>")
            return
        if symbol in self.ticker_output:
            del self.ticker_output[symbol]
            print(f"Stopped real-time trade output for {symbol}")
        else:
            self.ticker_output[symbol] = True
            print(f"Started real-time trade output for {symbol}")

    def candlestick_callback(self, symbol, minute, candle):
        """
        Callback for candlestick updates if toggled on via candles <symbol>.
        """
        if symbol in self.candlestick_output:
            ts_str = datetime.fromtimestamp(candle['timestamp']).strftime('%Y-%m-%d %H:%M:%S')
            print(f"{symbol} - {ts_str}: "
                  f"Open={candle['open']:.2f}, High={candle['high']:.2f}, "
                  f"Low={candle['low']:.2f}, Close={candle['close']:.2f}, "
                  f"Volume={candle['volume']}, Trades={candle['trades']}")

    def trade_callback(self, symbol, price, timestamp, trade_reason):
        """
        Callback for trade updates if toggled on via ticker <symbol>.
        """
        if symbol in self.ticker_output:
            ts_str = datetime.fromtimestamp(timestamp).strftime('%Y-%m-%d %H:%M:%S')
            print(f"{symbol} - {ts_str}: Price=${price:.2f}")

    def do_verbose(self, arg):
        """
        Enable verbose logging to console or to a specified log file: verbose [logfile]
        """
        arg = arg.strip()
        if not arg:
            if not self.verbose:
                self.logger.setLevel(logging.DEBUG)
                debug_handlers = [
                    h for h in self.logger.handlers
                    if isinstance(h, logging.StreamHandler) and h.level == logging.DEBUG
                ]
                if not debug_handlers:
                    debug_stream_handler = logging.StreamHandler(sys.stderr)
                    debug_stream_handler.setLevel(logging.DEBUG)
                    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
                    debug_stream_handler.setFormatter(formatter)
                    self.logger.addHandler(debug_stream_handler)
                self.data_manager.set_verbose(True)
                self.verbose = True
                print("Verbose mode enabled.")
            else:
                print("Verbose mode is already enabled.")
        else:
            log_file = arg
            for handler in self.logger.handlers[:]:
                if isinstance(handler, logging.FileHandler):
                    self.logger.removeHandler(handler)
            try:
                log_file_path = os.path.abspath(log_file)
                file_handler = logging.FileHandler(log_file_path)
                file_handler.setLevel(logging.DEBUG)
                formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
                file_handler.setFormatter(formatter)
                self.logger.addHandler(file_handler)
                self.data_manager.set_verbose(True)
                self.verbose = True
                print(f"Verbose logs being written to {log_file_path}.")
            except Exception as e:
                print(f"Failed to open log file {log_file}: {e}")

    def parse_order_options(self, args):
        options = {}
        for arg in args:
            if '=' in arg:
                key, value = arg.split('=', 1)
                if key in ['daily_order', 'ioc_order', 'fok_order', 'moc_order', 'gtd_order']:
                    options[key] = (value.lower() == 'true')
                elif key == 'expire_time':
                    try:
                        options[key] = int(value)
                    except ValueError:
                        print(f"Invalid value for {key}: {value} (should be int).")
                elif key == 'client_order_id':
                    options[key] = value
                elif key == 'limit_price':
                    try:
                        options[key] = float(value)
                    except ValueError:
                        print(f"Invalid value for {key}: {value} (should be float).")
        return options

    def do_limit_buy(self, arg):
        """
        Place a limit buy order: limit_buy <symbol> <amount> <price> [options]
        """
        args = arg.split()
        if len(args) < 3:
            print("Usage: limit_buy <symbol> <amount> <price> [options]")
            return
        symbol, amount, price = args[0].lower(), float(args[1]), float(args[2])
        options = self.parse_order_options(args[3:])
        result = self.order_placer.place_limit_buy_order(symbol, amount, price, **options)
        print(json.dumps(result, indent=2))

    def do_limit_sell(self, arg):
        """
        Place a limit sell order: limit_sell <symbol> <amount> <price> [options]
        """
        args = arg.split()
        if len(args) < 3:
            print("Usage: limit_sell <symbol> <amount> <price> [options]")
            return
        symbol, amount, price = args[0].lower(), float(args[1]), float(args[2])
        options = self.parse_order_options(args[3:])
        result = self.order_placer.place_limit_sell_order(symbol, amount, price, **options)
        print(json.dumps(result, indent=2))

    def parse_position_str(self, pos_str):
        """
        Convert 'long'|'short'|'neutral' to +1|-1|0.
        """
        pos_str = pos_str.lower()
        if pos_str == 'long':
            return 1
        elif pos_str == 'short':
            return -1
        elif pos_str == 'neutral':
            return 0
        else:
            return None

    def do_auto_trade(self, arg):
        """
        Start auto-trading using the best strategy from best_strategy.json.
        
        If hist_position == desired_position, we skip forcing an immediate trade 
        but we also set the cost basis as though we 'theoretically' opened that 
        position at the current market price. If short is requested but we have 
        no local BTC, we skip forced SELL but still treat ourselves as short 
        with a 'theoretical' cost basis. 
        """
        if self.auto_trader and self.auto_trader.running:
            print("Auto-trading is already running. Stop it first.")
            return

        args_list = arg.split()
        if len(args_list) != 2:
            print("Usage: auto_trade <amount><btc|usd> <long|short|neutral>")
            return

        balance_str = args_list[0].lower()
        pos_str = args_list[1].lower()

        desired_position = self.parse_position_str(pos_str)
        if desired_position is None:
            print("Position must be 'long', 'short', or 'neutral'.")
            return

        import re
        pattern = re.compile(r'^(\d+(\.\d+)?)(btc|usd)$')
        match = pattern.match(balance_str)
        if not match:
            print("Balance argument must be like 2.47btc or 234462usd.")
            return

        amount_num = float(match.group(1))
        amount_unit = match.group(3)
        if amount_unit == 'btc' and desired_position != 1:
            print("Error: If specifying BTC balance, you must start in a 'long' position.")
            return
        if amount_unit == 'usd' and desired_position != -1:
            print("Error: If specifying USD balance, you must start in a 'short' position.")
            return

        file_path = os.path.abspath('best_strategy.json')
        if not os.path.exists(file_path):
            print(f"Error: '{file_path}' not found.")
            return

        with open(file_path, 'r') as f:
            best_strategy_params = json.load(f)

        strategy_name = best_strategy_params.get('Strategy')

        # helper
        def user_has_btc():
            if not self.auto_trader:
                return False
            if self.auto_trader.balance_btc > 1e-8:
                return True
            return False

        if strategy_name == 'MA':
            from tdr import determine_initial_position  # local import

            short_window = int(best_strategy_params.get('Short_Window', 12))
            long_window  = int(best_strategy_params.get('Long_Window', 36))
            do_live      = best_strategy_params.get('do_live_trades', False)
            max_trades_day = best_strategy_params.get('max_trades_per_day', 5)

            df = self.data_manager.get_price_dataframe('btcusd').copy()
            if 'close' not in df.columns and 'price' in df.columns:
                df.rename(columns={'price': 'close'}, inplace=True)
            if df.empty:
                hist_position = 0
            else:
                hist_position = determine_initial_position(df, short_window, long_window)

            initial_balance_btc = 0.0
            initial_balance_usd = 0.0
            if desired_position == 1:
                initial_balance_btc = amount_num
            elif desired_position == -1:
                initial_balance_usd = amount_num

            self.auto_trader = MACrossoverStrategy(
                self.data_manager,
                short_window,
                long_window,
                amount_num,
                'btcusd',
                self.logger,
                live_trading=do_live,
                max_trades_per_day=max_trades_day,
                initial_position=desired_position,
                initial_balance_btc=initial_balance_btc,
                initial_balance_usd=initial_balance_usd
            )

            current_market_price = self.data_manager.get_current_price('btcusd') or 0.0

            # (1) hist_position == desired_position => set theoretical cost basis
            # (2) otherwise, attempt forced immediate trade if possible
            if desired_position == hist_position:
                if desired_position == 1 and current_market_price > 0:
                    if self.auto_trader.position_size < 1e-8:
                        self.auto_trader.position_size = amount_num
                        self.auto_trader.position_cost_basis = amount_num * current_market_price
                        self.logger.info(
                            f"(auto_trade) MA: Setting cost basis to {self.auto_trader.position_cost_basis:.2f} "
                            f"for an initial LONG of {amount_num} BTC at ${current_market_price:.2f}."
                        )
                        self.auto_trader.theoretical_trade = {
                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                            'direction': 'long',
                            'amount': amount_num,
                            'theoretical': True
                        }
                elif desired_position == -1 and current_market_price > 0:
                    short_btc = amount_num / current_market_price
                    if self.auto_trader.position_size > -1e-8 and short_btc > 0:
                        self.auto_trader.position_size = - short_btc
                        self.auto_trader.position_cost_basis = short_btc * current_market_price
                        self.logger.info(
                            f"(auto_trade) MA: Setting cost basis to {self.auto_trader.position_cost_basis:.2f} "
                            f"for an initial SHORT of {short_btc:.6f} BTC at ${current_market_price:.2f}."
                        )
                        self.auto_trader.theoretical_trade = {
                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                            'direction': 'short',
                            'amount': amount_num,
                            'theoretical': True
                        }
                else:
                    self.logger.info(f"(auto_trade) MA: No forced trade, positions match.")
            else:
                if desired_position == 1 and hist_position != 1 and current_market_price > 0:
                    buy_btc = amount_num / current_market_price
                    trade_ts = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    self.logger.info(f"(auto_trade) MA: Forcing immediate BUY for {buy_btc:.6f} BTC at ${current_market_price:.2f}.")
                    self.auto_trader.execute_trade(
                        "buy",
                        current_market_price,
                        trade_ts,
                        datetime.now(),
                        buy_btc
                    )
                elif desired_position == -1 and hist_position != -1 and current_market_price > 0:
                    if not user_has_btc():
                        self.logger.info("(auto_trade) MA: We have no BTC to sell, skipping forced SELL. Setting theoretical short anyway.")
                        short_btc = amount_num / current_market_price
                        self.auto_trader.position_size = -short_btc
                        self.auto_trader.position_cost_basis = short_btc * current_market_price
                        self.auto_trader.theoretical_trade = {
                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                            'direction': 'short',
                            'amount': amount_num,
                            'theoretical': True
                        }
                    else:
                        sell_btc = amount_num / current_market_price
                        trade_ts = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                        self.logger.info(f"(auto_trade) MA: Forcing immediate SELL for {sell_btc:.6f} BTC at ${current_market_price:.2f}.")
                        self.auto_trader.execute_trade(
                            "sell",
                            current_market_price,
                            trade_ts,
                            datetime.now(),
                            sell_btc
                        )

            self.auto_trader.start()
            print(f"Auto-trading started with {balance_str}, position={pos_str}, "
                  f"MA strategy (Short={short_window}, Long={long_window}), do_live_trades={do_live}")

        elif strategy_name == 'RSI':
            from tdr_core.shell import determine_rsi_position

            rsi_window = int(best_strategy_params.get('RSI_Window', 14))
            overbought = float(best_strategy_params.get('Overbought', 70))
            oversold   = float(best_strategy_params.get('Oversold', 30))
            do_live    = best_strategy_params.get('do_live_trades', False)
            max_trades_day = best_strategy_params.get('max_trades_per_day', 5)

            df = self.data_manager.get_price_dataframe('btcusd').copy()
            if 'close' not in df.columns and 'price' in df.columns:
                df.rename(columns={'price': 'close'}, inplace=True)

            if df.empty:
                hist_position = 0
            else:
                hist_position = determine_rsi_position(df, rsi_window, overbought, oversold)

            initial_balance_btc = 0.0
            initial_balance_usd = 0.0
            if desired_position == 1:
                initial_balance_btc = amount_num
            elif desired_position == -1:
                initial_balance_usd = amount_num

            self.auto_trader = RSITradingStrategy(
                self.data_manager,
                rsi_window,
                overbought,
                oversold,
                amount_num,
                'btcusd',
                self.logger,
                live_trading=do_live,
                max_trades_per_day=max_trades_day,
                initial_position=desired_position,
                initial_balance_btc=initial_balance_btc,
                initial_balance_usd=initial_balance_usd
            )

            current_market_price = self.data_manager.get_current_price('btcusd') or 0.0

            if desired_position == hist_position:
                if desired_position == 1 and current_market_price > 0:
                    if self.auto_trader.position_size < 1e-8:
                        self.auto_trader.position_size = amount_num
                        self.auto_trader.position_cost_basis = amount_num * current_market_price
                        self.logger.info(
                            f"(auto_trade) RSI: Setting cost basis to {self.auto_trader.position_cost_basis:.2f} "
                            f"for an initial LONG of {amount_num} BTC at ${current_market_price:.2f}."
                        )
                        self.auto_trader.theoretical_trade = {
                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                            'direction': 'long',
                            'amount': amount_num,
                            'theoretical': True
                        }
                elif desired_position == -1 and current_market_price > 0:
                    short_btc = amount_num / current_market_price
                    if self.auto_trader.position_size > -1e-8 and short_btc > 0:
                        self.auto_trader.position_size = - short_btc
                        self.auto_trader.position_cost_basis = short_btc * current_market_price
                        self.logger.info(
                            f"(auto_trade) RSI: Setting cost basis to {self.auto_trader.position_cost_basis:.2f} "
                            f"for an initial SHORT of {short_btc:.6f} BTC at ${current_market_price:.2f}."
                        )
                        self.auto_trader.theoretical_trade = {
                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                            'direction': 'short',
                            'amount': amount_num,
                            'theoretical': True
                        }
                else:
                    self.logger.info(f"(auto_trade) RSI: No forced trade, positions match.")
            else:
                if desired_position == 1 and hist_position != 1 and current_market_price > 0:
                    buy_btc = amount_num / current_market_price
                    trade_ts = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    self.logger.info(f"(auto_trade) RSI: Forcing immediate BUY for {buy_btc:.6f} BTC at ${current_market_price:.2f}.")
                    self.auto_trader.execute_trade(
                        "buy",
                        current_market_price,
                        trade_ts,
                        datetime.now(),
                        buy_btc
                    )
                elif desired_position == -1 and hist_position != -1 and current_market_price > 0:
                    if not user_has_btc():
                        self.logger.info("(auto_trade) RSI: We have no BTC to sell, skipping forced SELL. Setting theoretical short anyway.")
                        short_btc = amount_num / current_market_price
                        self.auto_trader.position_size = - short_btc
                        self.auto_trader.position_cost_basis = short_btc * current_market_price
                        self.auto_trader.theoretical_trade = {
                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                            'direction': 'short',
                            'amount': amount_num,
                            'theoretical': True
                        }
                    else:
                        sell_btc = amount_num / current_market_price
                        trade_ts = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                        self.logger.info(f"(auto_trade) RSI: Forcing immediate SELL for {sell_btc:.6f} BTC at ${current_market_price:.2f}.")
                        self.auto_trader.execute_trade(
                            "sell",
                            current_market_price,
                            trade_ts,
                            datetime.now(),
                            sell_btc
                        )

            self.auto_trader.start()
            print(f"Auto-trading started with {balance_str}, position={pos_str}, "
                  f"RSI strategy (Window={rsi_window}, Overbought={overbought}, Oversold={oversold}), do_live_trades={do_live}")

        else:
            print(f"Best strategy is not 'MA' or 'RSI'; it's {strategy_name}.")
            print("Currently supported: 'MA', 'RSI'.")
            return

    def do_stop_auto_trade(self, arg):
        """
        Stop auto-trading if running.
        """
        if self.auto_trader and self.auto_trader.running:
            self.auto_trader.stop()
            print("Auto-trading stopped.")
        else:
            print("No auto-trading is running.")

    def do_status(self, arg):
        """
        Show status of auto-trading. Usage: status [long]
        
        By default (no arg or anything not "long"), we show a short version:
          - Position Details with direction, plus theoretical trade block if relevant.
        If user types "status long", we show the entire original block.
        """
        sub_arg = arg.strip().lower()
        show_full = (sub_arg == 'long')

        if not self.auto_trader or not self.auto_trader.running:
            print("Auto-trading is not running.")
            return

        status = self.auto_trader.get_status()
        pos_str = {1:'Long', -1:'Short', 0:'Neutral'}.get(status['position'], 'Unknown')

        if not show_full:
            print("\nPosition Details (Short View):")
            print("━"*50)
            print(f"  • Direction: {pos_str}")
            pos_info = status.get('position_info', {})
            print(f"  • Current Price:  ${pos_info.get('current_price', 0.0):.2f}")
            print(f"  • Entry Price:    ${pos_info.get('entry_price', 0.0):.2f}")

            if status['position'] == 1:
                print(f"  • Position Size (BTC): {pos_info.get('position_size_btc', 0.0):.8f}")
                print(f"  • Position Value (USD): ${pos_info.get('position_size_usd', 0.0):.2f}")
            elif status['position'] == -1:
                print(f"  • Short Size (BTC): {pos_info.get('position_size_btc', 0.0):.8f} (negative means short)")
                print(f"  • USD Held:         ${pos_info.get('position_size_usd', 0.0):.2f}")
            else:
                print("  • Neutral position, no open BTC or short.")

            print(f"  • Unrealized PnL:  ${pos_info.get('unrealized_pnl', 0.0):.2f}")

            if status['trades_executed'] == 0 and status.get('theoretical_trade'):
                t = status['theoretical_trade']
                print(f"\n  This is a theoretical trade (no actual trades yet):")
                print(f"    • Timestamp:  {t['timestamp']}")
                print(f"    • Direction:  {t['direction']}")
                print(f"    • Amount:     {t['amount']}")
                print(f"    • Theoretical? {t['theoretical']}")

            proximity = status.get('ma_signal_proximity')
            if proximity is not None:
                print(f"\n  • MA Crossover Proximity: {proximity*100:.2f}%")
                print("    (Closer to 0% means closer to flipping from short->long or long->short)")

            print("")
            return

        # Otherwise, show the full (long) status:
        print("\nAuto-Trading Status:")
        print("━"*50)
        print(f"  • Running: {status['running']}")
        print(f"  • Position: {pos_str}")
        print(f"  • Daily Trades: {status['trade_count_today']}/{self.auto_trader.max_trades_per_day}")
        print(f"  • Remaining Trades Today: {status['remaining_trades_today']}")

        print("\nAccount Balances & Performance:")
        print(f"  • Initial USD Balance: ${status['initial_balance_usd']:.2f}")
        print(f"  • Initial BTC Balance: {status['initial_balance_btc']:.8f}")
        print(f"  • Current USD Balance: ${status['balance_usd']:.2f}")
        print(f"  • Current BTC Balance: {status['balance_btc']:.8f}")
        print(f"  • Total Return (vs initial): {status['total_return_pct']:.2f}%")
        print(f"  • Total P&L: ${status['total_profit_loss']:.2f}")
        print(f"  • Current Trade Amount: {status['current_amount']:.8f}")
        print(f"  • Total Fees Paid: ${status['total_fees_paid']:.2f}")

        print("\nMark-to-Market & Drawdowns:")
        print(f"  • Current MTM (USD): ${status['mark_to_market_usd']:.2f}")
        print(f"  • Current MTM (BTC): {status['mark_to_market_btc']:.8f}")
        print(f"  • Max MTM (USD): ${status['max_mtm_usd']:.2f}")
        print(f"  • Min MTM (USD): ${status['min_mtm_usd']:.2f}")
        print(f"  • Max USD Balance: ${status['max_balance_usd']:.2f}")
        print(f"  • Min USD Balance: ${status['min_balance_usd']:.2f}")
        print(f"  • Max BTC Balance: {status['max_balance_btc']:.8f}")
        print(f"  • Min BTC Balance: {status['min_balance_btc']:.8f}")

        pos_info = status.get('position_info', {})
        print("\nPosition Details:")
        print(f"  • Direction:  {pos_str}")
        print(f"  • Current Price:  ${pos_info.get('current_price', 0.0):.2f}")
        print(f"  • Entry Price:    ${pos_info.get('entry_price', 0.0):.2f}")
        if status['position'] == 1:
            print(f"  • Position Size (BTC): {pos_info.get('position_size_btc', 0.0):.8f}")
            print(f"  • Position Value (USD): ${pos_info.get('position_size_usd', 0.0):.2f}")
        elif status['position'] == -1:
            print(f"  • Short Size (BTC): {pos_info.get('position_size_btc', 0.0):.8f} (negative means short)")
            print(f"  • USD Held:         ${pos_info.get('position_size_usd', 0.0):.2f}")
        else:
            print("  • Neutral position, no open BTC or short.")
        print(f"  • Unrealized PnL:  ${pos_info.get('unrealized_pnl', 0.0):.2f}")

        print("\nTrading Statistics:")
        print(f"  • Total Trades: {status['trades_executed']}")
        print(f"  • Profitable Trades: {status['profitable_trades']}")
        print(f"  • Win Rate: {status['win_rate']:.1f}%")

        if status['trades_executed'] > 0:
            print(f"  • Avg Profit/Trade: ${status['average_profit_per_trade']:.2f}")
            print(f"  • Avg Fee/Trade: ${status.get('average_fee_per_trade', 0.0):.2f}")
            print(f"  • Risk/Reward Ratio: {status.get('risk_reward_ratio', 0.0):.2f}")

        if status['last_trade']:
            print("\nLast Trade Info:")
            print(f"  • Reason: {status['last_trade']}")
            print(f"  • Data Source: {status['last_trade_data_source']}")
            print(f"  • Signal Time: {status['last_trade_signal_timestamp']}")

        print("\nTechnical Analysis:")
        if status['next_trigger']:
            print(f"  • {status['next_trigger']}")
        if status.get('current_trends'):
            print("  • Current Trends:")
            for k, v in status['current_trends'].items():
                print(f"    ◦ {k}: {v}")
        if 'ma_difference' in status and status['ma_difference'] is not None:
            print(f"  • MA Difference: {status['ma_difference']:.4f}")
        if 'ma_slope_difference' in status and status['ma_slope_difference'] is not None:
            print(f"  • MA Slope Difference: {status['ma_slope_difference']:.4f}")
        if 'short_ma_momentum' in status:
            print(f"  • Short MA Momentum: {status['short_ma_momentum']}")
        if 'long_ma_momentum' in status:
            print(f"  • Long MA Momentum: {status['long_ma_momentum']}")
        if 'momentum_alignment' in status:
            print(f"  • Momentum Alignment: {status['momentum_alignment']}")

        # RSI debug info:
        if 'last_rsi' in status:
            print(f"  • Last RSI: {status['last_rsi']:.2f} (window={status.get('rsi_window',14)}, overbought={status.get('overbought',70)}, oversold={status.get('oversold',30)})")

        if status['trades_executed'] == 0:
            print("\nNo trades yet, stats are limited.")
        elif status['win_rate'] < 40:
            print("Warning: Win rate is below 40%. Consider reviewing parameters.")
        if status['current_balance'] < status['initial_balance']*0.9:
            print("Warning: Balance is over 10% below initial.")
        if status['remaining_trades_today'] <= 1:
            print("Warning: Approaching daily trade limit!")

        session_duration = datetime.now() - self.auto_trader.strategy_start_time
        hours = session_duration.total_seconds() / 3600
        print(f"\nSession Duration: {hours:.1f} hours\n")
        print("━"*50)

    def do_stop_auto_trade(self, arg):
        """
        Stop auto-trading if running.
        """
        if self.auto_trader and self.auto_trader.running:
            self.auto_trader.stop()
            print("Auto-trading stopped.")
        else:
            print("No auto-trading is running.")

    def do_quit(self, arg):
        """
        Quit the program, shutting down threads and processes gracefully.
        """
        print("Quitting...")
        if self.auto_trader and self.auto_trader.running:
            self.auto_trader.stop()
        if self.chart_process and self.chart_process.is_alive():
            self.stop_dash_app()
        if self.stop_event:
            self.stop_event.set()
        return True

    def do_exit(self, arg):
        """
        Alias for 'quit'.
        """
        return self.do_quit(arg)

    def stop_dash_app(self):
        """
        If a Dash app is running in a separate process, attempt to shut it down.
        """
        if self.chart_process and self.chart_process.is_alive():
            try:
                requests.get('http://127.0.0.1:8050/shutdown')
                self.chart_process.join()
                print("Dash app shut down.")
            except Exception as e:
                print("Failed to shut down Dash app:", e)

    def do_chart(self, arg):
        """
        Show a Dash-based chart: chart [symbol] [bar_size].
        E.g., chart btcusd 1H
        """
        args = arg.split()
        symbol = 'btcusd'
        bar_size = '1H'
        if len(args) >= 1:
            symbol = args[0].strip().lower()
        if len(args) >= 2:
            bar_size = args[1].strip()
        if symbol not in self.data_manager.data:
            print(f"No data for symbol '{symbol}'.")
            return

        try:
            import dash
            from dash import dcc, html
            from dash.dependencies import Output, Input
            import plotly.graph_objs as go
            from flask import Flask, request
            from multiprocessing import Process
        except ImportError:
            print("Install dash & plotly first (pip install dash plotly).")
            return

        short_window = 12
        long_window = 36
        if self.auto_trader and isinstance(self.auto_trader, MACrossoverStrategy):
            short_window = self.auto_trader.short_window
            long_window = self.auto_trader.long_window
        else:
            try:
                with open('best_strategy.json','r') as f:
                    best_params = json.load(f)
                if best_params.get('Strategy') == 'MA':
                    short_window = int(best_params['Short_Window'])
                    long_window = int(best_params['Long_Window'])
            except:
                print("Could not read 'best_strategy.json' for windows. Using defaults.")

        self.data_manager_dict[symbol] = self.data_manager.get_price_dataframe(symbol).to_dict('list')

        def update_shared_data():
            while not self.stop_event.is_set():
                self.data_manager_dict[symbol] = self.data_manager.get_price_dataframe(symbol).to_dict('list')
                time.sleep(60)

        threading.Thread(target=update_shared_data, daemon=True).start()

        from tdr import run_dash_app  # minimal local import
        self.chart_process = Process(
            target=run_dash_app,
            args=(self.data_manager_dict, symbol, bar_size, short_window, long_window)
        )
        self.chart_process.start()
        print("Dash app is running at http://127.0.0.1:8050/")
        time.sleep(1)

--- END FILE: tdr_core/shell.py ---

--- BEGIN FILE: tdr_core/strategies.py ---
###############################################################################
# src/tdr_core/strategies.py
###############################################################################
# FULL FILE PATH: src/tdr_core/strategies.py
#
# CONTEXT AND CHANGES:
#   - This file contains two classes: MACrossoverStrategy and RSITradingStrategy.
#   - We do NOT remove or alter existing functionality or comments. Instead, we
#     add minimal changes so that RSITradingStrategy performs partial buys (like
#     MACrossoverStrategy does) when it detects an RSI-based "long" signal. This
#     avoids "only buy 0E-8 BTC" exchange errors by splitting one large buy into
#     multiple smaller (partial) buys.
#
#   - Specifically, we replicate the MA approach:
#       1) We define a new method rsi_buy_in_three_parts(...) in RSITradingStrategy
#          (mirroring buy_in_three_parts(...) from MACrossoverStrategy).
#       2) We define a helper get_89pct_btc_of_usd(...) (like MA's get_89pct_btc_of_usd).
#       3) In check_for_signals(), if we detect RSI says "BUY," we call
#          rsi_buy_in_three_parts(...) instead of doing a single self.execute_trade.
#       4) All other RSI logic, comments, docstrings, and features remain intact.
#       5) We do NOT remove or break any existing function. We only add the new
#          partial-buy calls and the two new helper methods in RSITradingStrategy.
#
#   - We keep the entire file listing below, preserving original code for both
#     MACrossoverStrategy and RSITradingStrategy. We mark the minimal changes we
#     introduced with comments like “# NEW (PARTIAL BUY)” to clarify where they are.
#
# EXPLANATION of Potential Mistakes We Correct:
#   - If RSI strategy tried to do one big buy order for nearly all USD, small
#     fee differences might cause "You can only buy 0E-8 BTC" errors if the exchange
#     sees insufficient funds. Splitting into 3 partial buys is more flexible.
#   - We apologize for any previous code versions that deleted large sections
#     unnecessarily. This version adds partial-buy logic with minimal disruption
#     to everything else.
###############################################################################

import pandas as pd
import numpy as np
import json
import time
import logging
import threading
import os
from datetime import datetime, timedelta

from indicators.technical_indicators import (
    ensure_datetime_index,
    add_moving_averages,
    generate_ma_signals,
    calculate_rsi,
    generate_rsi_signals,
    calculate_bollinger_bands,
    generate_bollinger_band_signals,
    calculate_macd,
    generate_macd_signals
)
from tdr_core.trade import Trade


###############################################################################
class MACrossoverStrategy:
    """
    Implements a basic Moving Average Crossover strategy with position tracking
    and optional daily trade limits.
    """
    def __init__(
        self,
        data_manager,
        short_window,
        long_window,
        amount,
        symbol,
        logger,
        live_trading=False,
        max_trades_per_day=5,
        initial_position=0,
        initial_balance_btc=0.0,
        initial_balance_usd=0.0
    ):
        self.data_manager = data_manager
        self.order_placer = data_manager.order_placer
        self.short_window = short_window
        self.long_window = long_window
        self.initial_amount = amount
        self.current_amount = amount
        self.symbol = symbol
        self.logger = logger
        self.position = initial_position
        self.running = False
        self.live_trading = live_trading
        self.trade_log = []

        # Decide which trades file to use (live vs. non-live).
        if self.live_trading:
            self.trade_log_file = 'trades.json'
        else:
            self.trade_log_file = 'non-live-trades.json'

        self.last_signal_time = None
        self.last_trade_reason = None
        self.last_trade_data_source = None
        self.last_trade_signal_timestamp = None
        self.next_trigger = None
        self.current_trends = {}
        self.df_ma = pd.DataFrame()
        self.strategy_start_time = datetime.now()

        # Initial balances for BTC & USD (and legacy "amount" for P&L).
        self.initial_balance_btc = initial_balance_btc
        self.initial_balance_usd = initial_balance_usd
        self.initial_balance = amount
        self.current_balance = amount

        self.balance_btc = initial_balance_btc
        self.balance_usd = initial_balance_usd

        self.fee_percentage = 0.0012
        self.last_trade_price = None
        self.total_fees_paid = 0
        self.trades_executed = 0
        self.profitable_trades = 0
        self.total_profit_loss = 0

        # Daily trade limits
        self.max_trades_per_day = max_trades_per_day
        self.trade_count_today = 0
        self.current_day = datetime.utcnow().date()
        self.logger.debug(f"Trade limit set to {self.max_trades_per_day} trades/day.")

        self.trades_this_hour = []

        # Cost basis logic
        self.position_cost_basis = 0.0
        self.position_size = 0.0

        # For storing an initial theoretical trade if hist_position matches user request
        self.theoretical_trade = None

        # Register real-time callback
        data_manager.add_trade_observer(self.check_instant_signal)

        # Track staleness detection
        mtm_usd, _ = self.get_mark_to_market_values()
        self.max_mtm_usd = mtm_usd
        self.min_mtm_usd = mtm_usd
        self.max_balance_usd = self.balance_usd
        self.min_balance_usd = self.balance_usd
        self.max_balance_btc = self.balance_btc
        self.min_balance_btc = self.balance_btc

    def _clean_up_hourly_trades(self):
        one_hour_ago = datetime.utcnow() - timedelta(hours=1)
        self.trades_this_hour = [t for t in self.trades_this_hour if t > one_hour_ago]

    def start(self):
        """
        Start the strategy loop in a background thread.
        """
        self.running = True
        self.strategy_thread = threading.Thread(target=self.run_strategy_loop, daemon=True)
        self.strategy_thread.start()
        self.logger.info("Strategy loop started.")

    def stop(self):
        """
        Stop the strategy loop and, if in live mode, real trades are presumably
        appended as they happen. If in dry-run, we finalize the trade logs now.
        """
        self.running = False
        self.logger.info("Strategy loop stopped.")
        if not self.live_trading and self.trade_log:
            try:
                file_path = os.path.abspath(self.trade_log_file)
                with open(file_path, 'w') as f:
                    json.dump([t.to_dict() for t in self.trade_log], f, indent=2)
                self.logger.info(f"Trades logged to '{file_path}' (dry-run mode).")
            except Exception as e:
                self.logger.error(f"Failed to write trades: {e}")

    def calculate_fee(self, trade_amount, price):
        trade_value = trade_amount * price
        return trade_value * self.fee_percentage

    def run_strategy_loop(self):
        """
        Strategy loop that checks for signals every minute.
        """
        while self.running:
            df = self.data_manager.get_price_dataframe(self.symbol)
            if not df.empty:
                try:
                    df = ensure_datetime_index(df)
                    df_resampled = df.resample('1H').agg({
                        'open': 'first',
                        'high': 'max',
                        'low': 'min',
                        'close': 'last',
                        'volume': 'sum',
                        'trades': 'sum',
                        'timestamp': 'last',
                        'source': 'last'
                    }).dropna()

                    if len(df_resampled) >= self.long_window:
                        df_ma = add_moving_averages(df_resampled.copy(), self.short_window, self.long_window, price_col='close')
                        df_ma = generate_ma_signals(df_ma)

                        latest_signal = df_ma.iloc[-1]['MA_Signal']
                        signal_time = df_ma.index[-1]
                        current_price = df_ma.iloc[-1]['close']
                        signal_source = df_ma.iloc[-1]['source']

                        self.next_trigger = self.determine_next_trigger(df_ma)
                        self.current_trends = self.get_current_trends(df_ma)
                        self.df_ma = df_ma

                        # Check signals (MA crossover)
                        self.check_for_signals(latest_signal, current_price, signal_time)
                    else:
                        self.logger.debug("Not enough data to compute MAs.")
                except Exception as e:
                    self.logger.error(f"Error in strategy loop for {self.symbol}: {e}")
            else:
                self.logger.debug(f"No data loaded for {self.symbol} yet.")
            time.sleep(60)

    def determine_next_trigger(self, df_ma):
        """
        Return text describing the potential next trigger, if signals changed.
        """
        if len(df_ma) < 2:
            return None
        last_signal = df_ma.iloc[-1]['MA_Signal']
        prev_signal = df_ma.iloc[-2]['MA_Signal']
        if last_signal != prev_signal:
            if last_signal == 1:
                return "Next trigger: Potential SELL if short crosses below long."
            elif last_signal == -1:
                return "Next trigger: Potential BUY if short crosses above long."
        return "Next trigger: Awaiting next crossover signal."

    def get_current_trends(self, df_ma):
        """
        Analyze short/long MA slopes and price trend.
        """
        if len(df_ma) < 2:
            return {}
        short_ma_curr = df_ma.iloc[-1]['Short_MA']
        short_ma_prev = df_ma.iloc[-2]['Short_MA']
        long_ma_curr = df_ma.iloc[-1]['Long_MA']
        long_ma_prev = df_ma.iloc[-2]['Long_MA']

        short_ma_slope = short_ma_curr - short_ma_prev
        long_ma_slope  = long_ma_curr - long_ma_prev

        return {
            'Short_MA_Slope': 'Upwards' if short_ma_slope > 0 else 'Downwards',
            'Long_MA_Slope': 'Upwards' if long_ma_slope > 0 else 'Downwards',
            'Price_Trend': 'Bullish' if short_ma_curr > long_ma_curr else 'Bearish',
            'Trend_Strength': abs(short_ma_curr - long_ma_curr) / long_ma_curr * 100 if long_ma_curr else 0
        }

    def check_instant_signal(self, symbol, price, timestamp, trade_reason):
        """
        Real-time callback for each new trade. If there's a new crossover, act now.
        """
        if not self.running:
            return
        if symbol != self.symbol:
            return

        df_live = self.data_manager.get_price_dataframe(symbol)
        if df_live.empty:
            return

        df_live = ensure_datetime_index(df_live)
        if len(df_live) < self.long_window:
            return

        df_ma = df_live.copy()
        df_ma['Short_MA'] = df_ma['close'].rolling(self.short_window).mean()
        df_ma['Long_MA']  = df_ma['close'].rolling(self.long_window).mean()
        df_ma.dropna(inplace=True)
        if df_ma.empty:
            return

        latest = df_ma.iloc[-1]
        short_ma_now = latest['Short_MA']
        long_ma_now  = latest['Long_MA']
        signal_now = 1 if short_ma_now > long_ma_now else -1

        if len(df_ma) < 2:
            return
        prev = df_ma.iloc[-2]
        prev_signal = 1 if prev['Short_MA'] > prev['Long_MA'] else -1
        if signal_now == prev_signal:
            return

        signal_time = df_ma.index[-1]
        self.check_for_signals(signal_now, price, signal_time)

    def check_for_signals(self, latest_signal, current_price, signal_time):
        """
        If the new MA signal differs from our current position, place trades.
        Also checks daily trade-limit; if at max, it skips.
        """
        today = datetime.utcnow().date()
        if today != self.current_day:
            self.current_day = today
            self.trade_count_today = 0
            self.logger.debug("New day, resetting daily trade count.")

        if self.last_signal_time == signal_time:
            return

        # If we see a BUY signal
        if latest_signal == 1 and self.position <= 0:
            if self.trade_count_today >= self.max_trades_per_day:
                self.logger.info(f"Reached daily trade limit {self.max_trades_per_day}, skipping trade.")
                return

            self.logger.info(f"Buy signal triggered at {current_price}")
            self.position = 1
            self.last_trade_reason = "MA Crossover: short above long."
            self.buy_in_three_parts(
                current_price, datetime.now().strftime('%Y-%m-%d %H:%M:%S'), signal_time
            )
            self.trade_count_today += 1
            self.last_signal_time = signal_time

        # If we see a SELL signal
        elif latest_signal == -1 and self.position >= 0:
            if self.trade_count_today >= self.max_trades_per_day:
                self.logger.info(f"Reached daily trade limit {self.max_trades_per_day}, skipping trade.")
                return

            self.logger.info(f"Sell signal triggered at {current_price}")
            self.position = -1
            self.last_trade_reason = "MA Crossover: short below long."
            trade_btc = round(self.balance_btc, 8)
            self.execute_trade(
                "sell",
                current_price,
                datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                signal_time,
                trade_btc
            )
            self.trade_count_today += 1
            self.last_signal_time = signal_time

    def buy_in_three_parts(self, price, timestamp, signal_time):
        """
        Simulate a multi-part buy so we can keep within a 90% rule but only
        1 daily "signal" used. We do partial trades to avoid insufficient
        balance issues.
        """
        partial_btc_1 = self.get_89pct_btc_of_usd(price)
        self.execute_trade("buy", price, timestamp, signal_time, partial_btc_1)

        partial_btc_2 = self.get_89pct_btc_of_usd(price)
        self.execute_trade("buy", price, timestamp, signal_time, partial_btc_2)

        partial_btc_3 = self.get_89pct_btc_of_usd(price)
        self.execute_trade("buy", price, timestamp, signal_time, partial_btc_3)

    def get_89pct_btc_of_usd(self, price):
        available_usd = self.balance_usd * 0.89
        btc_approx = available_usd / (price * (1 + self.fee_percentage))
        return round(btc_approx, 8)

    def execute_trade(self, trade_type, price, timestamp, signal_time, trade_btc):
        """
        Execute a single trade. 
        If trade_btc < 1e-8, skip to avoid confusion with a near-zero fill.
        If live_trading=True, append trades to trades.json right away.
        """
        if trade_btc < 1e-8:
            self.logger.debug(f"Skipping trade because fill_btc is too small: {trade_btc}")
            return

        self._clean_up_hourly_trades()
        max_trades_per_hour = 3
        if len(self.trades_this_hour) >= max_trades_per_hour:
            self.logger.info(f"Reached hourly trade limit {max_trades_per_hour}, skipping trade.")
            return

        trade_info = Trade(
            trade_type,
            self.symbol,
            trade_btc,
            price,
            datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S'),
            self.last_trade_reason,
            'live' if self.live_trading else 'historical',
            signal_time,
            live_trading=self.live_trading
        )

        self.last_trade_data_source = trade_info.data_source
        self.last_trade_signal_timestamp = signal_time

        # Place order with the exchange if live
        if self.live_trading:
            result = self.order_placer.place_order(f"market-{trade_type}", self.symbol, trade_btc)
            self.logger.info(f"Executed LIVE {trade_type} order: {result}")
            trade_info.order_result = result
            if result.get("status") == "error":
                self.logger.error(f"Trade failed: {result}")
                self._log_failed_trade(trade_info)
                return
            # Update balances & cost basis
            self.update_balance(trade_type, price, trade_btc)

            # Append to trades.json right away
            try:
                file_path = os.path.abspath(self.trade_log_file)
                if not os.path.exists(file_path):
                    existing_trades = []
                else:
                    with open(file_path, 'r') as f:
                        try:
                            existing_trades = json.load(f)
                        except json.JSONDecodeError:
                            existing_trades = []
                existing_trades.append(trade_info.to_dict())
                with open(file_path, 'w') as f:
                    json.dump(existing_trades, f, indent=2)
                self.logger.debug(f"Appended live trade to {self.trade_log_file}")
            except Exception as e:
                self.logger.error(f"Failed to write live trade: {e}")

        else:
            # Dry-run => local simulation only
            self.logger.info(f"Executed DRY RUN {trade_type} order: {trade_info.to_dict()}")
            self.trade_log.append(trade_info)
            self.update_balance(trade_type, price, trade_btc)

        self.trades_this_hour.append(datetime.utcnow())
        self._log_successful_trade(trade_info)

        # If a theoretical trade existed, clear it
        if self.theoretical_trade is not None:
            self.logger.debug("Clearing theoretical trade because an actual trade occurred.")
            self.theoretical_trade = None

    def update_balance(self, trade_type, fill_price, fill_btc):
        """
        Update local USD/BTC balances after a trade, tracking cost basis,
        partial fills, etc. We keep the existing logic for partial close
        of short or long. We do not remove or break existing code.
        """
        fee = self.calculate_fee(fill_btc, fill_price)
        self.total_fees_paid += fee

        if trade_type == "buy":
            cost_usd = fill_btc * fill_price
            total_cost_usd = cost_usd + fee
            if total_cost_usd > self.balance_usd:
                # partial fill correction
                possible_btc = self.balance_usd / (fill_price * (1 + self.fee_percentage))
                possible_btc = round(possible_btc, 8)
                if possible_btc < 1e-8:
                    self.logger.debug(f"Cannot buy anything with leftover USD. Skipping.")
                    return
                fill_btc = possible_btc
                cost_usd = fill_btc * fill_price
                fee = self.calculate_fee(fill_btc, fill_price)
                total_cost_usd = cost_usd + fee

            self.balance_usd -= total_cost_usd
            self.balance_btc += fill_btc

            # If going long or adding to existing long
            if self.position_size >= 0:
                self.position_cost_basis += (fill_btc * fill_price)
                self.position_size += fill_btc
            else:
                # partial close logic if we were short
                short_cover_size = min(abs(self.position_size), fill_btc)
                ratio = short_cover_size / abs(self.position_size)
                cost_removed = ratio * self.position_cost_basis
                self.position_cost_basis -= cost_removed
                self.position_size += short_cover_size

                leftover_btc_for_long = fill_btc - short_cover_size
                if leftover_btc_for_long > 1e-8:
                    self.position_size += leftover_btc_for_long
                    self.position_cost_basis += leftover_btc_for_long * fill_price

            if self.last_trade_price is not None and self.position == -1:
                profit = fill_btc * (self.last_trade_price - fill_price) - fee
                self.current_balance += profit
                self.total_profit_loss += profit
                if profit > 0:
                    self.profitable_trades += 1

        elif trade_type == "sell":
            proceeds_usd = fill_btc * fill_price
            fee_sell = proceeds_usd * self.fee_percentage
            fee = fee_sell
            net_usd = proceeds_usd - fee

            self.balance_btc -= fill_btc
            self.balance_usd += net_usd

            if self.position_size > 0:
                # partial or full close of a long
                if fill_btc > self.position_size:
                    # going from long to short
                    fill_btc_for_long = self.position_size
                    ratio = 1.0
                    cost_removed = self.position_cost_basis
                    self.position_cost_basis -= cost_removed
                    self.position_size -= fill_btc_for_long
                    leftover_btc_for_short = fill_btc - fill_btc_for_long
                    if leftover_btc_for_short > 1e-8:
                        self.position_size -= leftover_btc_for_short
                        self.position_cost_basis += leftover_btc_for_short * fill_price
                else:
                    # partial or full flatten only
                    ratio = fill_btc / self.position_size
                    cost_removed = ratio * self.position_cost_basis
                    self.position_cost_basis -= cost_removed
                    self.position_size -= fill_btc

            else:
                # We were neutral or short => add to short
                self.position_size -= fill_btc
                self.position_cost_basis += (fill_btc * fill_price)

            if self.last_trade_price is not None and self.position == 1:
                profit = fill_btc * (fill_price - self.last_trade_price) - fee
                self.current_balance += profit
                self.total_profit_loss += profit
                if profit > 0:
                    self.profitable_trades += 1

        self.last_trade_price = fill_price
        self.trades_executed += 1

        # Recompute 'current_amount' for old P&L logic
        ratio = self.current_balance / self.initial_balance if self.initial_balance else 1
        self.current_amount = self.initial_amount * ratio

        if self.balance_usd > self.max_balance_usd:
            self.max_balance_usd = self.balance_usd
        if self.balance_usd < self.min_balance_usd:
            self.min_balance_usd = self.balance_usd
        if self.balance_btc > self.max_balance_btc:
            self.max_balance_btc = self.balance_btc
        if self.balance_btc < self.min_balance_btc:
            self.min_balance_btc = self.balance_btc

        mtm_usd, _ = self.get_mark_to_market_values()
        if mtm_usd > self.max_mtm_usd:
            self.max_mtm_usd = mtm_usd
        if mtm_usd < self.min_mtm_usd:
            self.min_mtm_usd = mtm_usd

        self.logger.info(
            f"Trade completed - Balance: ${self.current_balance:.2f}, "
            f"Fees: ${fee:.2f}, Next trade amount: {self.current_amount:.8f}, "
            f"Total P&L: ${self.total_profit_loss:.2f} || "
            f"[BTC Balance: {self.balance_btc:.8f}, USD Balance: {self.balance_usd:.2f}]"
        )

    def get_mark_to_market_values(self):
        current_price = self.data_manager.get_current_price(self.symbol) or 0.0
        total_usd_value = self.balance_usd + (self.balance_btc * current_price)
        total_btc_value = self.balance_btc + (self.balance_usd / current_price if current_price else 0.0)
        return total_usd_value, total_btc_value

    def get_status(self):
        status = {
            'running': self.running,
            'position': self.position,
            'last_trade': None,
            'last_trade_data_source': None,
            'last_trade_signal_timestamp': None,
            'next_trigger': self.next_trigger,
            'current_trends': self.current_trends,
            'ma_difference': None,
            'ma_slope_difference': None,
            'initial_balance_btc': self.initial_balance_btc,
            'initial_balance_usd': self.initial_balance_usd,
            'initial_balance': self.initial_balance,
            'current_balance': self.current_balance,
            'balance_btc': self.balance_btc,
            'balance_usd': self.balance_usd,
            'total_return_pct': ((self.current_balance / self.initial_balance) - 1) * 100 if self.initial_balance != 0 else 0,
            'total_fees_paid': self.total_fees_paid,
            'trades_executed': self.trades_executed,
            'profitable_trades': self.profitable_trades,
            'win_rate': (self.profitable_trades / self.trades_executed * 100) if self.trades_executed else 0,
            'current_amount': self.current_amount,
            'total_profit_loss': self.total_profit_loss,
            'average_profit_per_trade': (self.total_profit_loss / self.trades_executed) if self.trades_executed else 0,
            'trade_count_today': self.trade_count_today,
            'remaining_trades_today': max(0, self.max_trades_per_day - self.trade_count_today),
            'theoretical_trade': self.theoretical_trade
        }

        if self.last_trade_reason:
            status['last_trade'] = self.last_trade_reason
            status['last_trade_data_source'] = self.last_trade_data_source
            if self.last_trade_signal_timestamp:
                status['last_trade_signal_timestamp'] = self.last_trade_signal_timestamp.strftime('%Y-%m-%d %H:%M:%S')

        # If we want to show short - long difference
        if hasattr(self, 'df_ma') and not self.df_ma.empty:
            status['ma_difference'] = self.df_ma.iloc[-1]['Short_MA'] - self.df_ma.iloc[-1]['Long_MA']
            if len(self.df_ma) >= 2:
                short_ma_slope = self.df_ma.iloc[-1]['Short_MA'] - self.df_ma.iloc[-2]['Short_MA']
                long_ma_slope  = self.df_ma.iloc[-1]['Long_MA'] - self.df_ma.iloc[-2]['Long_MA']
                status['ma_slope_difference'] = short_ma_slope - long_ma_slope
                status['short_ma_momentum'] = 'Increasing' if short_ma_slope > 0 else 'Decreasing'
                status['long_ma_momentum']  = 'Increasing' if long_ma_slope > 0 else 'Decreasing'
                status['momentum_alignment'] = (
                    'Aligned' if (short_ma_slope > 0 and long_ma_slope > 0)
                    or (short_ma_slope < 0 and long_ma_slope < 0)
                    else 'Diverging'
                )

        if self.trades_executed > 0:
            status['average_fee_per_trade'] = self.total_fees_paid / self.trades_executed
            status['risk_reward_ratio'] = (
                abs(self.total_profit_loss / self.total_fees_paid) if self.total_fees_paid > 0 else 0
            )

        mtm_usd, mtm_btc = self.get_mark_to_market_values()
        status['mark_to_market_usd'] = mtm_usd
        status['mark_to_market_btc'] = mtm_btc

        if mtm_usd > self.max_mtm_usd:
            self.max_mtm_usd = mtm_usd
        if mtm_usd < self.min_mtm_usd:
            self.min_mtm_usd = mtm_usd

        status['max_balance_usd'] = self.max_balance_usd
        status['min_balance_usd'] = self.min_balance_usd
        status['max_balance_btc'] = self.max_balance_btc
        status['min_balance_btc'] = self.min_balance_btc
        status['max_mtm_usd'] = self.max_mtm_usd
        status['min_mtm_usd'] = self.min_mtm_usd

        # Build position_info
        position_info = {
            'current_price': self.data_manager.get_current_price(self.symbol) or 0.0,
            'entry_price': 0.0,
            'position_size_btc': 0.0,
            'position_size_usd': 0.0,
            'unrealized_pnl': 0.0,
        }

        cp = position_info['current_price']
        if self.position == 1 and self.position_size > 1e-8:
            avg_entry_price = (self.position_cost_basis / self.position_size) if self.position_size else 0.0
            position_info['entry_price'] = avg_entry_price
            position_info['position_size_btc'] = self.position_size
            position_info['position_size_usd'] = self.position_size * cp
            cost_basis = self.position_cost_basis
            mark_value = self.position_size * cp
            position_info['unrealized_pnl'] = mark_value - cost_basis

        elif self.position == -1 and self.position_size < -1e-8:
            avg_entry_price = 0.0
            if abs(self.position_size) > 1e-8:
                avg_entry_price = self.position_cost_basis / abs(self.position_size)
            position_info['entry_price'] = avg_entry_price
            position_info['position_size_btc'] = self.position_size
            position_info['position_size_usd'] = self.position_cost_basis
            mark_value = abs(self.position_size) * cp
            position_info['unrealized_pnl'] = self.position_cost_basis - mark_value

        status['position_info'] = position_info

        return status

    def _log_successful_trade(self, trade_info):
        self.logger.info(f"Trade executed successfully: {trade_info.to_dict()}")

    def _log_failed_trade(self, trade_info):
        self.logger.info(f"Trade failed/canceled: {trade_info.to_dict()}")


###############################################################################
# RSITradingStrategy
###############################################################################
class RSITradingStrategy:
    """
    Implements a basic RSI-based strategy with position tracking and optional
    daily trade limits. If RSI < oversold => go long, if RSI > overbought => go
    short. We now add partial-buy logic (like MA's buy_in_three_parts) so that
    when RSI triggers a BUY, we do multiple smaller purchases instead of one big
    order. This helps avoid 'only buy 0E-8 BTC' exchange errors.
    """
    def __init__(
        self,
        data_manager,
        rsi_window,
        overbought,
        oversold,
        amount,
        symbol,
        logger,
        live_trading=False,
        max_trades_per_day=5,
        initial_position=0,
        initial_balance_btc=0.0,
        initial_balance_usd=0.0
    ):
        self.data_manager = data_manager
        self.order_placer = data_manager.order_placer
        self.rsi_window = rsi_window
        self.overbought = overbought
        self.oversold = oversold
        self.initial_amount = amount
        self.current_amount = amount
        self.symbol = symbol
        self.logger = logger
        self.position = initial_position
        self.running = False
        self.live_trading = live_trading
        self.trade_log = []

        # Decide which trades file to use (live vs. non-live).
        if self.live_trading:
            self.trade_log_file = 'trades.json'
        else:
            self.trade_log_file = 'non-live-trades.json'

        self.last_signal_time = None
        self.last_trade_reason = None
        self.last_trade_data_source = None
        self.last_trade_signal_timestamp = None
        self.next_trigger = None
        self.df_rsi = pd.DataFrame()
        self.strategy_start_time = datetime.now()

        # Initial balances for BTC & USD
        self.initial_balance_btc = initial_balance_btc
        self.initial_balance_usd = initial_balance_usd
        self.initial_balance = amount
        self.current_balance = amount

        self.balance_btc = initial_balance_btc
        self.balance_usd = initial_balance_usd

        self.fee_percentage = 0.0012
        self.last_trade_price = None
        self.total_fees_paid = 0
        self.trades_executed = 0
        self.profitable_trades = 0
        self.total_profit_loss = 0

        # Daily trade limits
        self.max_trades_per_day = max_trades_per_day
        self.trade_count_today = 0
        self.current_day = datetime.utcnow().date()
        self.logger.debug(f"Trade limit set to {self.max_trades_per_day} trades/day.")

        self.trades_this_hour = []

        # Cost basis logic
        self.position_cost_basis = 0.0
        self.position_size = 0.0

        # For storing an initial theoretical trade if hist_position matches user request
        self.theoretical_trade = None

        # Register real-time callback
        data_manager.add_trade_observer(self.check_instant_signal)

        # Track staleness detection
        mtm_usd, _ = self.get_mark_to_market_values()
        self.max_mtm_usd = mtm_usd
        self.min_mtm_usd = mtm_usd
        self.max_balance_usd = self.balance_usd
        self.min_balance_usd = self.balance_usd
        self.max_balance_btc = self.balance_btc
        self.min_balance_btc = self.balance_btc

    def _clean_up_hourly_trades(self):
        """
        Keep track of trades in the last hour to limit trades per hour.
        We do not remove this method or its logic.
        """
        one_hour_ago = datetime.utcnow() - timedelta(hours=1)
        self.trades_this_hour = [t for t in self.trades_this_hour if t > one_hour_ago]

    def start(self):
        """
        Start the RSI strategy loop in a background thread.
        """
        self.running = True
        self.strategy_thread = threading.Thread(target=self.run_strategy_loop, daemon=True)
        self.strategy_thread.start()
        self.logger.info("RSI strategy loop started.")

    def stop(self):
        """
        Stop the RSI strategy loop and finalize logs if in dry-run mode.
        """
        self.running = False
        self.logger.info("RSI strategy loop stopped.")
        if not self.live_trading and self.trade_log:
            try:
                file_path = os.path.abspath(self.trade_log_file)
                with open(file_path, 'w') as f:
                    json.dump([t.to_dict() for t in self.trade_log], f, indent=2)
                self.logger.info(f"Trades logged to '{file_path}' (dry-run mode).")
            except Exception as e:
                self.logger.error(f"Failed to write trades: {e}")

    def calculate_fee(self, trade_amount, price):
        """
        Consistent fee calculation. We do not remove this existing function.
        """
        trade_value = trade_amount * price
        return trade_value * self.fee_percentage

    def run_strategy_loop(self):
        """
        Strategy loop that checks RSI signals every minute.
        """
        while self.running:
            df = self.data_manager.get_price_dataframe(self.symbol)
            if not df.empty:
                try:
                    df = ensure_datetime_index(df)
                    # We'll do an hourly RSI check
                    df_resampled = df.resample('1H').agg({
                        'open': 'first',
                        'high': 'max',
                        'low': 'min',
                        'close': 'last',
                        'volume': 'sum',
                        'trades': 'sum',
                        'timestamp': 'last',
                        'source': 'last'
                    }).dropna()

                    if len(df_resampled) >= self.rsi_window:
                        df_rsi = df_resampled.copy()
                        df_rsi = calculate_rsi(df_rsi, window=self.rsi_window, price_col='close')
                        # Generate RSI_Signal
                        df_rsi['RSI_Signal'] = 0
                        df_rsi.loc[df_rsi['RSI'] < self.oversold, 'RSI_Signal'] = 1
                        df_rsi.loc[df_rsi['RSI'] > self.overbought, 'RSI_Signal'] = -1

                        latest_signal = df_rsi.iloc[-1]['RSI_Signal']
                        signal_time = df_rsi.index[-1]
                        current_price = df_rsi.iloc[-1]['close']
                        signal_source = df_rsi.iloc[-1]['source']

                        self.df_rsi = df_rsi
                        self.check_for_signals(latest_signal, current_price, signal_time)
                    else:
                        self.logger.debug("Not enough data to compute RSI.")
                except Exception as e:
                    self.logger.error(f"Error in RSI strategy loop for {self.symbol}: {e}")
            else:
                self.logger.debug(f"No data loaded for {self.symbol} yet.")
            time.sleep(60)

    def check_instant_signal(self, symbol, price, timestamp, trade_reason):
        """
        Real-time callback for each new trade. If there's a new RSI signal,
        we do a mini RSI check on the live data. This can open immediate trades
        if RSI crosses thresholds.
        """
        if not self.running:
            return
        if symbol != self.symbol:
            return

        df_live = self.data_manager.get_price_dataframe(symbol)
        if df_live.empty or len(df_live) < self.rsi_window:
            return

        df_live = ensure_datetime_index(df_live)
        df_rsi = calculate_rsi(df_live.copy(), window=self.rsi_window, price_col='close')
        last_rsi = df_rsi.iloc[-1]['RSI']
        if last_rsi < self.oversold:
            latest_signal = 1
        elif last_rsi > self.overbought:
            latest_signal = -1
        else:
            return

        signal_time = df_rsi.index[-1]
        self.check_for_signals(latest_signal, price, signal_time)

    def check_for_signals(self, latest_signal, current_price, signal_time):
        """
        If RSI indicates buy (1) or sell (-1), see if it differs from our current
        position, place partial trades if daily limit not exceeded.
        """
        today = datetime.utcnow().date()
        if today != self.current_day:
            self.current_day = today
            self.trade_count_today = 0
            self.logger.debug("New day, resetting daily trade count.")

        if self.last_signal_time == signal_time:
            return

        # BUY if RSI_Signal=1 and position <= 0
        if latest_signal == 1 and self.position <= 0:
            if self.trade_count_today >= self.max_trades_per_day:
                self.logger.info(f"Reached daily trade limit {self.max_trades_per_day}, skipping RSI buy.")
                return

            self.logger.info(f"RSI Buy signal triggered at {current_price}")
            self.position = 1
            self.last_trade_reason = f"RSI < {self.oversold}"
            # NEW (PARTIAL BUY): replicate MA's approach
            self.rsi_buy_in_three_parts(
                current_price,
                datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                signal_time
            )
            self.trade_count_today += 1
            self.last_signal_time = signal_time

        # SELL if RSI_Signal=-1 and position >= 0
        elif latest_signal == -1 and self.position >= 0:
            if self.trade_count_today >= self.max_trades_per_day:
                self.logger.info(f"Reached daily trade limit {self.max_trades_per_day}, skipping RSI sell.")
                return

            self.logger.info(f"RSI Sell signal triggered at {current_price}")
            self.position = -1
            self.last_trade_reason = f"RSI > {self.overbought}"
            trade_btc = round(self.balance_btc, 8)
            self.execute_trade(
                "sell",
                current_price,
                datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                signal_time,
                trade_btc
            )
            self.trade_count_today += 1
            self.last_signal_time = signal_time

    # NEW (PARTIAL BUY) ------------
    def rsi_buy_in_three_parts(self, price, timestamp, signal_time):
        """
        Similar to MACrossoverStrategy.buy_in_three_parts:
        do three smaller buys, each about 89% of self.balance_usd,
        to avoid 'only buy 0E-8 BTC' errors from fees or small leftover funds.
        """
        partial_btc_1 = self.get_89pct_btc_of_usd(price)
        self.execute_trade("buy", price, timestamp, signal_time, partial_btc_1)

        partial_btc_2 = self.get_89pct_btc_of_usd(price)
        self.execute_trade("buy", price, timestamp, signal_time, partial_btc_2)

        partial_btc_3 = self.get_89pct_btc_of_usd(price)
        self.execute_trade("buy", price, timestamp, signal_time, partial_btc_3)
    # END (PARTIAL BUY) ------------

    # NEW HELPER (like MA's get_89pct_btc_of_usd)
    def get_89pct_btc_of_usd(self, price):
        """
        Use ~89% of our current balance_usd (minus fees) for each partial buy.
        """
        available_usd = self.balance_usd * 0.89
        btc_approx = available_usd / (price * (1 + self.fee_percentage))
        return round(btc_approx, 8)

    def execute_trade(self, trade_type, price, timestamp, signal_time, trade_btc):
        """
        Execute a single trade. We do NOT remove any existing code or logic.
        We keep partial close logic, fee logic, etc. We only add the new partial
        buy calls in check_for_signals().
        """
        if trade_btc < 1e-8:
            self.logger.debug(f"(RSI) Skipping trade because fill_btc is too small: {trade_btc}")
            return

        self._clean_up_hourly_trades()
        max_trades_per_hour = 3
        if len(self.trades_this_hour) >= max_trades_per_hour:
            self.logger.info(f"Reached hourly trade limit {max_trades_per_hour}, skipping trade.")
            return

        trade_info = Trade(
            trade_type,
            self.symbol,
            trade_btc,
            price,
            datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S'),
            self.last_trade_reason,
            'live' if self.live_trading else 'historical',
            signal_time,
            live_trading=self.live_trading
        )

        self.last_trade_data_source = trade_info.data_source
        self.last_trade_signal_timestamp = signal_time

        # Place order with the exchange if live.
        if self.live_trading:
            result = self.order_placer.place_order(f"market-{trade_type}", self.symbol, trade_btc)
            self.logger.info(f"(RSI) Executed LIVE {trade_type} order: {result}")
            trade_info.order_result = result
            if result.get("status") == "error":
                self.logger.error(f"(RSI) Trade failed: {result}")
                self._log_failed_trade(trade_info)
                return
            self.update_balance(trade_type, price, trade_btc)

            # Immediately save to trades.json
            try:
                file_path = os.path.abspath(self.trade_log_file)
                if not os.path.exists(file_path):
                    existing_trades = []
                else:
                    with open(file_path, 'r') as f:
                        try:
                            existing_trades = json.load(f)
                        except json.JSONDecodeError:
                            existing_trades = []
                existing_trades.append(trade_info.to_dict())
                with open(file_path, 'w') as f:
                    json.dump(existing_trades, f, indent=2)
                self.logger.debug(f"(RSI) Appended live trade to {self.trade_log_file}")
            except Exception as e:
                self.logger.error(f"(RSI) Failed to write live trade: {e}")

        else:
            # Dry-run => local simulation
            self.logger.info(f"(RSI) Executed DRY RUN {trade_type} order: {trade_info.to_dict()}")
            self.trade_log.append(trade_info)
            self.update_balance(trade_type, price, trade_btc)

        self.trades_this_hour.append(datetime.utcnow())
        self._log_successful_trade(trade_info)

        if self.theoretical_trade is not None:
            self.logger.debug("(RSI) Clearing theoretical trade because an actual trade occurred.")
            self.theoretical_trade = None

    def update_balance(self, trade_type, fill_price, fill_btc):
        """
        Update local USD/BTC balances for RSI trades, preserving the partial fill
        logic, cost basis updates, etc. We keep all original code.
        """
        fee = self.calculate_fee(fill_btc, fill_price)
        self.total_fees_paid += fee

        if trade_type == "buy":
            cost_usd = fill_btc * fill_price
            total_cost_usd = cost_usd + fee
            if total_cost_usd > self.balance_usd:
                # partial fill correction
                possible_btc = self.balance_usd / (fill_price * (1 + self.fee_percentage))
                possible_btc = round(possible_btc, 8)
                if possible_btc < 1e-8:
                    self.logger.debug(f"(RSI) Cannot buy anything with leftover USD. Skipping.")
                    return
                fill_btc = possible_btc
                cost_usd = fill_btc * fill_price
                fee = self.calculate_fee(fill_btc, fill_price)
                total_cost_usd = cost_usd + fee

            self.balance_usd -= total_cost_usd
            self.balance_btc += fill_btc

            if self.position_size >= 0:
                self.position_cost_basis += (fill_btc * fill_price)
                self.position_size += fill_btc
            else:
                short_cover_size = min(abs(self.position_size), fill_btc)
                ratio = short_cover_size / abs(self.position_size)
                cost_removed = ratio * self.position_cost_basis
                self.position_cost_basis -= cost_removed
                self.position_size += short_cover_size

                leftover_btc_for_long = fill_btc - short_cover_size
                if leftover_btc_for_long > 1e-8:
                    self.position_size += leftover_btc_for_long
                    self.position_cost_basis += leftover_btc_for_long * fill_price

            if self.last_trade_price is not None and self.position == -1:
                profit = fill_btc * (self.last_trade_price - fill_price) - fee
                self.current_balance += profit
                self.total_profit_loss += profit
                if profit > 0:
                    self.profitable_trades += 1

        elif trade_type == "sell":
            proceeds_usd = fill_btc * fill_price
            fee_sell = proceeds_usd * self.fee_percentage
            fee = fee_sell
            net_usd = proceeds_usd - fee

            self.balance_btc -= fill_btc
            self.balance_usd += net_usd

            if self.position_size > 0:
                if fill_btc > self.position_size:
                    fill_btc_for_long = self.position_size
                    ratio = 1.0
                    cost_removed = self.position_cost_basis
                    self.position_cost_basis -= cost_removed
                    self.position_size -= fill_btc_for_long
                    leftover_btc_for_short = fill_btc - fill_btc_for_long
                    if leftover_btc_for_short > 1e-8:
                        self.position_size -= leftover_btc_for_short
                        self.position_cost_basis += leftover_btc_for_short * fill_price
                else:
                    ratio = fill_btc / self.position_size
                    cost_removed = ratio * self.position_cost_basis
                    self.position_cost_basis -= cost_removed
                    self.position_size -= fill_btc
            else:
                self.position_size -= fill_btc
                self.position_cost_basis += (fill_btc * fill_price)

        self.last_trade_price = fill_price
        self.trades_executed += 1

        ratio = self.current_balance / self.initial_balance if self.initial_balance else 1
        self.current_amount = self.initial_amount * ratio

        # If we changed from last trade
        if trade_type == "sell" and self.position == 1 and self.last_trade_price is not None:
            profit = fill_btc * (fill_price - self.last_trade_price) - fee
            self.current_balance += profit
            self.total_profit_loss += profit
            if profit > 0:
                self.profitable_trades += 1
        elif trade_type == "buy" and self.position == -1 and self.last_trade_price is not None:
            profit = fill_btc * (self.last_trade_price - fill_price) - fee
            self.current_balance += profit
            self.total_profit_loss += profit
            if profit > 0:
                self.profitable_trades += 1

        if self.balance_usd > self.max_balance_usd:
            self.max_balance_usd = self.balance_usd
        if self.balance_usd < self.min_balance_usd:
            self.min_balance_usd = self.balance_usd
        if self.balance_btc > self.max_balance_btc:
            self.max_balance_btc = self.balance_btc
        if self.balance_btc < self.min_balance_btc:
            self.min_balance_btc = self.balance_btc

        mtm_usd, _ = self.get_mark_to_market_values()
        if mtm_usd > self.max_mtm_usd:
            self.max_mtm_usd = mtm_usd
        if mtm_usd < self.min_mtm_usd:
            self.min_mtm_usd = mtm_usd

        self.logger.info(
            f"(RSI) Trade completed - Balance: ${self.current_balance:.2f}, "
            f"Fees: ${fee:.2f}, Next trade amount: {self.current_amount:.8f}, "
            f"Total P&L: ${self.total_profit_loss:.2f} || "
            f"[BTC Balance: {self.balance_btc:.8f}, USD Balance: {self.balance_usd:.2f}]"
        )

    def get_mark_to_market_values(self):
        current_price = self.data_manager.get_current_price(self.symbol) or 0.0
        total_usd_value = self.balance_usd + (self.balance_btc * current_price)
        total_btc_value = self.balance_btc + (self.balance_usd / current_price if current_price else 0.0)
        return total_usd_value, total_btc_value

    def get_status(self):
        status = {
            'running': self.running,
            'position': self.position,
            'last_trade': None,
            'last_trade_data_source': None,
            'last_trade_signal_timestamp': None,
            'rsi_window': self.rsi_window,
            'overbought': self.overbought,
            'oversold': self.oversold,
            'initial_balance_btc': self.initial_balance_btc,
            'initial_balance_usd': self.initial_balance_usd,
            'initial_balance': self.initial_balance,
            'current_balance': self.current_balance,
            'balance_btc': self.balance_btc,
            'balance_usd': self.balance_usd,
            'total_return_pct': ((self.current_balance / self.initial_balance) - 1) * 100 if self.initial_balance != 0 else 0,
            'total_fees_paid': self.total_fees_paid,
            'trades_executed': self.trades_executed,
            'profitable_trades': self.profitable_trades,
            'win_rate': (self.profitable_trades / self.trades_executed * 100) if self.trades_executed else 0,
            'current_amount': self.current_amount,
            'total_profit_loss': self.total_profit_loss,
            'average_profit_per_trade': (self.total_profit_loss / self.trades_executed) if self.trades_executed else 0,
            'trade_count_today': self.trade_count_today,
            'remaining_trades_today': max(0, self.max_trades_per_day - self.trade_count_today),
            'theoretical_trade': self.theoretical_trade
        }

        if self.last_trade_reason:
            status['last_trade'] = self.last_trade_reason
            status['last_trade_data_source'] = self.last_trade_data_source
            if self.last_trade_signal_timestamp:
                status['last_trade_signal_timestamp'] = self.last_trade_signal_timestamp.strftime('%Y-%m-%d %H:%M:%S')

        # If we want to store rsi or last signals
        if hasattr(self, 'df_rsi') and not self.df_rsi.empty:
            last_rsi = self.df_rsi.iloc[-1]['RSI']
            status['last_rsi'] = last_rsi

        if self.trades_executed > 0:
            status['average_fee_per_trade'] = self.total_fees_paid / self.trades_executed
            status['risk_reward_ratio'] = (
                abs(self.total_profit_loss / self.total_fees_paid) if self.total_fees_paid > 0 else 0
            )

        mtm_usd, mtm_btc = self.get_mark_to_market_values()
        status['mark_to_market_usd'] = mtm_usd
        status['mark_to_market_btc'] = mtm_btc

        if mtm_usd > self.max_mtm_usd:
            self.max_mtm_usd = mtm_usd
        if mtm_usd < self.min_mtm_usd:
            self.min_mtm_usd = mtm_usd

        status['max_balance_usd'] = self.max_balance_usd
        status['min_balance_usd'] = self.min_balance_usd
        status['max_balance_btc'] = self.max_balance_btc
        status['min_balance_btc'] = self.min_balance_btc
        status['max_mtm_usd'] = self.max_mtm_usd
        status['min_mtm_usd'] = self.min_mtm_usd

        # Build position_info
        position_info = {
            'current_price': self.data_manager.get_current_price(self.symbol) or 0.0,
            'entry_price': 0.0,
            'position_size_btc': 0.0,
            'position_size_usd': 0.0,
            'unrealized_pnl': 0.0,
        }

        cp = position_info['current_price']
        if self.position == 1 and self.position_size > 1e-8:
            avg_entry_price = (self.position_cost_basis / self.position_size) if self.position_size else 0.0
            position_info['entry_price'] = avg_entry_price
            position_info['position_size_btc'] = self.position_size
            position_info['position_size_usd'] = self.position_size * cp
            cost_basis = self.position_cost_basis
            mark_value = self.position_size * cp
            position_info['unrealized_pnl'] = mark_value - cost_basis

        elif self.position == -1 and self.position_size < -1e-8:
            avg_entry_price = 0.0
            if abs(self.position_size) > 1e-8:
                avg_entry_price = self.position_cost_basis / abs(self.position_size)
            position_info['entry_price'] = avg_entry_price
            position_info['position_size_btc'] = self.position_size
            position_info['position_size_usd'] = self.position_cost_basis
            mark_value = abs(self.position_size) * cp
            position_info['unrealized_pnl'] = self.position_cost_basis - mark_value

        status['position_info'] = position_info

        return status

    def _log_successful_trade(self, trade_info):
        self.logger.info(f"(RSI) Trade executed successfully: {trade_info.to_dict()}")

    def _log_failed_trade(self, trade_info):
        self.logger.info(f"(RSI) Trade failed/canceled: {trade_info.to_dict()}")

--- END FILE: tdr_core/strategies.py ---

--- BEGIN FILE: tdr_core/trade.py ---
# src/tdr_core/trade.py

from datetime import datetime

###############################################################################
class Trade:
    """
    Represents a single trade, whether historical or live.
    """
    def __init__(
        self,
        trade_type,
        symbol,
        amount,
        price,
        timestamp,
        reason,
        data_source,
        signal_timestamp,
        live_trading=False,
        order_result=None
    ):
        self.type = trade_type
        self.symbol = symbol
        self.amount = amount
        self.price = price
        self.timestamp = timestamp
        self.reason = reason
        self.data_source = data_source
        self.signal_timestamp = signal_timestamp
        self.live_trading = live_trading
        self.order_result = order_result

    def to_dict(self):
        """
        Convert the Trade object to a dictionary for logging/JSON.
        """
        trade_info = {
            'type': self.type,
            'symbol': self.symbol,
            'amount': self.amount,
            'price': self.price,
            'timestamp': self.timestamp.strftime('%Y-%m-%d %H:%M:%S'),
            'signal_timestamp': self.signal_timestamp.strftime('%Y-%m-%d %H:%M:%S'),
            'data_source': self.data_source,
            'live_trading': self.live_trading,
            'reason': self.reason
        }
        if self.order_result:
            trade_info['order_result'] = self.order_result
        return trade_info

--- END FILE: tdr_core/trade.py ---

--- BEGIN FILE: tdr_core/websocket_client.py ---
# src/tdr_core/websocket_client.py

import asyncio
import websockets
import json
import logging
from datetime import datetime

###############################################################################
async def subscribe_to_websocket(url: str, symbol: str, data_manager, stop_event):
    """
    Async function to subscribe to the Bitstamp WebSocket for a given symbol,
    storing new trades into data_manager.

    If more than 2 minutes pass with no incoming trades, attempt reconnect.
    """
    # NOTE: We preserve the original references to STALE_FEED_SECONDS by 
    # passing it through if needed. For minimal changes, we keep this as-is
    # but we might need to import or define STALE_FEED_SECONDS locally 
    # if the logic is required here.

    # For demonstration, we keep the same code.
    STALE_FEED_SECONDS = 120
    channel = f"live_trades_{symbol}"

    while not stop_event.is_set():
        last_message_time = datetime.utcnow()
        try:
            data_manager.logger.info(f"{symbol}: Attempting to connect to WebSocket...")
            async with websockets.connect(url) as websocket:
                data_manager.logger.info(f"{symbol}: Connected to WebSocket.")

                subscribe_message = {
                    "event": "bts:subscribe",
                    "data": {"channel": channel}
                }
                await websocket.send(json.dumps(subscribe_message))
                data_manager.logger.info(f"{symbol}: Subscribed to channel: {channel}")

                while not stop_event.is_set():
                    now = datetime.utcnow()
                    seconds_since_last = (now - last_message_time).total_seconds()
                    if seconds_since_last > STALE_FEED_SECONDS:
                        data_manager.logger.warning(
                            f"{symbol}: No trades in {seconds_since_last:.0f} s. Reconnecting..."
                        )
                        break

                    try:
                        # Wait for data up to 10s
                        message = await asyncio.wait_for(websocket.recv(), timeout=10)
                    except asyncio.TimeoutError:
                        continue

                    data_manager.logger.debug(f"{symbol}: {message}")
                    data = json.loads(message)
                    if data.get('event') == 'trade':
                        price = data['data']['price']
                        timestamp = int(float(data['data']['timestamp']))
                        data_manager.add_trade(symbol, price, timestamp, "Live Trade")
                        last_message_time = datetime.utcnow()

        except websockets.ConnectionClosed:
            if stop_event.is_set():
                break
            data_manager.logger.error(f"{symbol}: Connection closed, retrying in 5 seconds...")
            await asyncio.sleep(5)
        except Exception as e:
            if stop_event.is_set():
                break
            data_manager.logger.error(f"{symbol}: An error occurred: {str(e)}")
            await asyncio.sleep(5)

--- END FILE: tdr_core/websocket_client.py ---

--- BEGIN FILE: utils/__init__.py ---
# src/utils/__init__.py

--- END FILE: utils/__init__.py ---

--- BEGIN FILE: utils/analysis.py ---
###############################################################################
# src/utils/analysis.py
###############################################################################
# Full File Path: src/utils/analysis.py
#
# CHANGES:
#   1) We added a new parameter only_ma=False to run_trading_system().
#   2) If only_ma=True, we SKIP all non-MA strategy optimizations (RSI, Bollinger Bands, MACD, RAMM, Adaptive VWMA).
#   3) We preserve all original code, logic, comments, etc., simply wrapping the existing strategies
#      in an "if not only_ma" block.
#   4) All existing logic remains, so if only_ma=False, everything proceeds as before.
###############################################################################

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import json
import traceback
import os
from indicators.technical_indicators import ensure_datetime_index
from backtesting.backtester import generate_trade_list
from optimization.optimizer import (
    optimize_ma_parameters,
    optimize_rsi_parameters,
    optimize_hft_parameters,
    optimize_ramm_parameters,
    optimize_adaptive_vwma_parameters,
    optimize_ma_frequency
)
from strategies.ramm_strategy import calculate_ramm_signals
from indicators.technical_indicators import (
    add_moving_averages,
    generate_ma_signals,
    calculate_rsi,
    generate_rsi_signals,
    calculate_bollinger_bands,
    generate_bollinger_band_signals,
    calculate_macd,
    generate_macd_signals,
    calculate_adaptive_vwma,
    generate_adaptive_vwma_signals
)
from utils.helpers import ensure_datetime_index, print_strategy_results


def analyze_data(df):
    print("Converting timestamp to datetime...")
    df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')
    print("Calculating basic statistics...")
    print(df.describe())
    print("Plotting price over time...")
    plt.figure(figsize=(12, 6))
    plt.plot(df['datetime'], df['price'])
    plt.title('Bitcoin Price Over Time')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.savefig('btc_price_over_time.png')
    plt.close()
    print("Calculating and plotting hourly trading volume...")
    df['volume'] = df['price'] * df['amount']
    df.set_index('datetime', inplace=True)
    hourly_volume = df['volume'].resample('H').sum()
    plt.figure(figsize=(12, 6))
    plt.bar(hourly_volume.index, hourly_volume.values, width=0.02)
    plt.title('Hourly Trading Volume')
    plt.xlabel('Date')
    plt.ylabel('Volume (USD)')
    plt.savefig('btc_hourly_volume.png')
    plt.close()
    df.reset_index(inplace=True)
    print("Analysis complete. Check the current directory for generated PNG files.")


###############################################################################
# CHANGED: Now accepts config with constraint settings
# ALSO CHANGED: now accepts only_ma=False to skip other strategies
###############################################################################
def run_trading_system(df, high_frequency='1H', low_frequency='15T', max_iterations=50,
                       config=None, only_ma=False):
    print("Starting run_trading_system function...")
    df = ensure_datetime_index(df)
    print(f"DataFrame shape after ensuring datetime index: {df.shape}")

    # If config is None, default it to an empty dict
    # so we don't get KeyError below
    if config is None:
        config = {}

    # Extract our constraints (with fallback defaults)
    constraints = config.get("strategy_constraints", {})
    min_trades_per_day  = constraints.get("min_trades_per_day", 1)
    max_trades_per_day  = constraints.get("max_trades_per_day", 4)
    min_total_return    = constraints.get("min_total_return", 0.0)
    min_profit_per_trade = constraints.get("min_profit_per_trade", 0.0)

    # Resample data to higher timeframe
    print(f"Resampling data to higher timeframe ({high_frequency})...")
    df['volume'] = df['price'] * df['amount']
    df_high = df.resample(high_frequency).agg({
        'price': 'last',
        'amount': 'sum',
        'volume': 'sum'
    }).dropna()
    df_high['timestamp'] = df_high.index.view('int64') // 10**9
    print(f"Higher timeframe DataFrame shape: {df_high.shape}")

    # Resample data to lower timeframe
    print(f"Resampling data to lower timeframe ({low_frequency})...")
    df_low = df.resample(low_frequency).agg({
        'price': 'last',
        'amount': 'sum',
        'volume': 'sum'
    }).dropna()
    df_low['timestamp'] = df_low.index.view('int64') // 10**9
    print(f"Lower timeframe DataFrame shape: {df_low.shape}")

    strategies = {}
    all_results_list = []

    # NEW: Dictionary to hold final DataFrames used for each "best" strategy
    strategy_dfs = {}  # We'll store e.g. strategy_dfs['MA'] = best_ma_df, etc.

    print("Running MA Crossover Strategy...")
    ma_results = optimize_ma_parameters(
        df_high,
        range(4, 25, 2),
        range(26, 51, 2),
        min_trades_per_day=min_trades_per_day,
        max_trades_per_day=max_trades_per_day,
        min_total_return=min_total_return,
        min_profit_per_trade=min_profit_per_trade
    )

    if not ma_results.empty:
        best_ma = ma_results.loc[ma_results['Total_Return'].idxmax()]
        print("Initial MA Crossover parameters:")
        print(best_ma)
        
        # Add frequency optimization for best parameters
        print("\nOptimizing trading frequency for best MA parameters...")
        freq_results = optimize_ma_frequency(df, {
            'Short_Window': int(best_ma['Short_Window']),
            'Long_Window': int(best_ma['Long_Window'])
        })
        
        if not freq_results.empty:
            best_freq_result = freq_results.loc[freq_results['Total_Return'].idxmax()]
            print("\nBest frequency results:")
            print(best_freq_result)
            
            # Update the best MA parameters with frequency-optimized version
            best_ma = best_freq_result
            
        # Generate trade list using best parameters
        best_ma_df = add_moving_averages(
            df_high.copy(), 
            int(best_ma['Short_Window']), 
            int(best_ma['Long_Window'])
        )
        best_ma_df = generate_ma_signals(best_ma_df)
        
        print("Best MA Crossover parameters:")
        print(best_ma)
        
        ma_trades = generate_trade_list(best_ma_df, 'MA')
        ma_trades.to_csv('ma_trades.csv', index=False)
        print("MA Crossover trades saved to 'ma_trades.csv'")

        strategy_dfs['MA'] = best_ma_df
        
        # Save frequency optimization results if available
        if 'freq_results' in locals() and not freq_results.empty:
            freq_results.to_csv('ma_frequency_optimization.csv', index=False)
            print("Frequency optimization results saved to 'ma_frequency_optimization.csv'")
            
        strategies['MA'] = best_ma.to_dict()
        all_results_list.append(ma_results)
    else:
        print("No MA Crossover strategies met the criteria.")

    ###########################################################################
    # If only_ma is True, then we skip all the other strategies below.
    ###########################################################################
    if not only_ma:
        # ----------------------------------------------------
        # RSI Strategy
        # ----------------------------------------------------
        print("Running RSI Strategy...")
        rsi_results = optimize_rsi_parameters(
            df_high,
            range(10, 21, 2),
            range(65, 81, 5),
            range(20, 36, 5),
            min_trades_per_day=min_trades_per_day,
            max_trades_per_day=max_trades_per_day,
            min_total_return=min_total_return,
            min_profit_per_trade=min_profit_per_trade
        )
        if not rsi_results.empty:
            best_rsi = rsi_results.loc[rsi_results['Total_Return'].idxmax()]
            print("Best RSI parameters:")
            print(best_rsi)
            strategies['RSI'] = best_rsi.to_dict()
            all_results_list.append(rsi_results)

            print("Generating trade list for best RSI strategy...")
            best_rsi_df = calculate_rsi(df_high.copy(), int(best_rsi['RSI_Window']))
            best_rsi_df = generate_rsi_signals(best_rsi_df,
                                               int(best_rsi['Overbought']),
                                               int(best_rsi['Oversold']))
            rsi_trades = generate_trade_list(best_rsi_df, 'RSI')
            rsi_trades.to_csv('rsi_trades.csv', index=False)
            print("RSI trades saved to 'rsi_trades.csv'")

            strategy_dfs['RSI'] = best_rsi_df
        else:
            print("No RSI strategies met the criteria.")

        # ----------------------------------------------------
        # Bollinger Bands Strategy
        # ----------------------------------------------------
        print("Running Bollinger Bands Strategy...")
        bb_param_grid = [{'window': w, 'num_std': s}
                         for w in range(10, 31, 5) for s in [1.5, 2, 2.5]]
        bb_results = optimize_hft_parameters(
            df_low,
            'BB',
            param_grid=bb_param_grid,
            min_trades_per_day=min_trades_per_day,
            max_trades_per_day=max_trades_per_day,
            min_total_return=min_total_return,
            min_profit_per_trade=min_profit_per_trade
        )
        if not bb_results.empty:
            best_bb = bb_results.loc[bb_results['Total_Return'].idxmax()]
            print("Best Bollinger Bands parameters:")
            print(best_bb)
            strategies['Bollinger Bands'] = best_bb.to_dict()
            all_results_list.append(bb_results)

            print("Generating trade list for best Bollinger Bands strategy...")
            best_bb_df = calculate_bollinger_bands(
                df_low.copy(),
                window=int(best_bb['window']),
                num_std=best_bb['num_std']
            )
            best_bb_df = generate_bollinger_band_signals(best_bb_df)
            bb_trades = generate_trade_list(best_bb_df, 'BB')
            bb_trades.to_csv('bb_trades.csv', index=False)
            print("Bollinger Bands trades saved to 'bb_trades.csv'")

            strategy_dfs['Bollinger Bands'] = best_bb_df
        else:
            print("No Bollinger Bands strategies met the criteria.")

        # ----------------------------------------------------
        # MACD Strategy
        # ----------------------------------------------------
        print("Running MACD Strategy...")
        macd_param_grid = [{'fast': f, 'slow': s, 'signal': sig}
                           for f in [6, 12, 18]
                           for s in [20, 26, 32]
                           for sig in [7, 9, 11]]
        macd_results = optimize_hft_parameters(
            df_low,
            'MACD',
            param_grid=macd_param_grid,
            min_trades_per_day=min_trades_per_day,
            max_trades_per_day=max_trades_per_day,
            min_total_return=min_total_return,
            min_profit_per_trade=min_profit_per_trade
        )
        if not macd_results.empty:
            best_macd = macd_results.loc[macd_results['Total_Return'].idxmax()]
            print("Best MACD parameters:")
            print(best_macd)
            strategies['MACD'] = best_macd.to_dict()
            all_results_list.append(macd_results)

            print("Generating trade list for best MACD strategy...")
            best_macd_df = calculate_macd(
                df_low.copy(),
                fast=int(best_macd['fast']),
                slow=int(best_macd['slow']),
                signal=int(best_macd['signal'])
            )
            best_macd_df = generate_macd_signals(best_macd_df)
            macd_trades = generate_trade_list(best_macd_df, 'MACD')
            macd_trades.to_csv('macd_trades.csv', index=False)
            print("MACD trades saved to 'macd_trades.csv'")

            strategy_dfs['MACD'] = best_macd_df
        else:
            print("No MACD strategies met the criteria.")

        # ----------------------------------------------------
        # RAMM Strategy
        # ----------------------------------------------------
        print("Running RAMM Strategy...")
        ramm_results = optimize_ramm_parameters(
            df_high,
            max_iterations=max_iterations,
            min_trades_per_day=min_trades_per_day,
            max_trades_per_day=max_trades_per_day,
            min_total_return=min_total_return,
            min_profit_per_trade=min_profit_per_trade
        )
        if not ramm_results.empty:
            best_ramm = ramm_results.loc[ramm_results['Total_Return'].idxmax()]
            print("Best RAMM parameters:")
            print(best_ramm)
            strategies['RAMM'] = best_ramm.to_dict()
            all_results_list.append(ramm_results)

            print("Generating trade list for best RAMM strategy...")
            best_ramm_df = calculate_ramm_signals(
                df_high.copy(),
                ma_short=int(best_ramm['MA_Short']),
                ma_long=int(best_ramm['MA_Long']),
                rsi_period=int(best_ramm['RSI_Period']),
                rsi_ob=int(best_ramm['RSI_Overbought']),
                rsi_os=int(best_ramm['RSI_Oversold']),
                regime_lookback=int(best_ramm['Regime_Lookback'])
            )
            ramm_trades = generate_trade_list(best_ramm_df, 'RAMM')
            ramm_trades.to_csv('ramm_trades.csv', index=False)
            print("RAMM trades saved to 'ramm_trades.csv'")

            strategy_dfs['RAMM'] = best_ramm_df
        else:
            print("No RAMM strategies met the criteria.")

        # ----------------------------------------------------
        # Adaptive VWMA Strategy
        # ----------------------------------------------------
        print("Running Adaptive VWMA Strategy...")
        adaptive_vwma_results = optimize_adaptive_vwma_parameters(
            df_high,
            min_trades_per_day=min_trades_per_day,
            max_trades_per_day=max_trades_per_day,
            min_total_return=min_total_return,
            min_profit_per_trade=min_profit_per_trade
        )
        if not adaptive_vwma_results.empty:
            best_adaptive_vwma = adaptive_vwma_results.loc[adaptive_vwma_results['Total_Return'].idxmax()]
            print("Best Adaptive VWMA parameters:")
            print(best_adaptive_vwma)
            strategies['Adaptive_VWMA'] = best_adaptive_vwma.to_dict()
            all_results_list.append(adaptive_vwma_results)

            print("Generating trade list for best Adaptive VWMA strategy...")
            best_adaptive_vwma_df = calculate_adaptive_vwma(
                df_high.copy(),
                base_window=int(best_adaptive_vwma['Base_Window'])
            )
            best_adaptive_vwma_df = generate_adaptive_vwma_signals(
                best_adaptive_vwma_df,
                vol_scale=best_adaptive_vwma['Volume_Scale']
            )
            adaptive_vwma_trades = generate_trade_list(best_adaptive_vwma_df, 'Adaptive_VWMA')
            adaptive_vwma_trades.to_csv('adaptive_vwma_trades.csv', index=False)
            print("Adaptive VWMA trades saved to 'adaptive_vwma_trades.csv'")

            strategy_dfs['Adaptive_VWMA'] = best_adaptive_vwma_df
        else:
            print("No Adaptive VWMA strategies met the criteria.")

    # -------------------------------------------------------------------------
    # Summaries & best-strategy logic remain the same
    # -------------------------------------------------------------------------
    if strategies:
        print("Preparing detailed strategy results...")
        print_strategy_results(strategies)

        print("\nStrategy Comparison:")
        comparison_df = pd.DataFrame.from_dict(strategies, orient='index')
        print(comparison_df)

        # Safely extract and compare total returns
        total_returns = {name: result.get('Total_Return', 0)
                         for name, result in strategies.items()}

        if total_returns:
            best_strategy = max(total_returns.items(), key=lambda x: x[1])[0]
            print(f"\nBest overall strategy: {best_strategy}")
            print(f"Best strategy Total Return: {total_returns[best_strategy]:.2f}%")

            # Save the best strategy parameters to a JSON file
            def convert_types(value):
                if isinstance(value, (np.integer, np.int64)):
                    return int(value)
                elif isinstance(value, (np.floating, np.float64)):
                    return float(value)
                elif isinstance(value, np.ndarray):
                    return value.tolist()
                elif isinstance(value, pd.Timestamp):
                    return value.isoformat()
                else:
                    return value

            best_strategy_params_converted = {
                key: convert_types(value) for key, value in strategies[best_strategy].items()
            }

            # Determine the last non-zero signal for the best strategy
            df_best = strategy_dfs.get(best_strategy, None)
            if df_best is not None:
                if best_strategy == "Bollinger Bands":
                    signal_col = "BB_Signal"
                else:
                    signal_col = f"{best_strategy}_Signal".replace(" ", "_")

                last_signals = df_best[df_best[signal_col] != 0]
                if not last_signals.empty:
                    last_row = last_signals.iloc[-1]
                    last_signal_value = last_row[signal_col]
                    best_strategy_params_converted["Last_Signal_Timestamp"] = int(last_row["timestamp"])
                    if last_signal_value == 1:
                        best_strategy_params_converted["Last_Signal_Action"] = "GO LONG"
                    else:
                        best_strategy_params_converted["Last_Signal_Action"] = "GO SHORT"
                else:
                    best_strategy_params_converted["Last_Signal_Timestamp"] = None
                    best_strategy_params_converted["Last_Signal_Action"] = None

            # Also store the last trade's timestamp and price
            if not df.empty:
                best_strategy_params_converted["Last_Trade_Timestamp"] = int(df['timestamp'].iloc[-1])
                best_strategy_params_converted["Last_Trade_Price"] = float(df['price'].iloc[-1])
            else:
                best_strategy_params_converted["Last_Trade_Timestamp"] = None
                best_strategy_params_converted["Last_Trade_Price"] = None

            # Ensure do_live_trades = false
            best_strategy_params_converted["do_live_trades"] = False

            try:
                with open('best_strategy.json', 'w') as f:
                    json.dump(best_strategy_params_converted, f, indent=4)
                print("\nBest strategy parameters saved to 'best_strategy.json'")
            except Exception as e:
                print("An error occurred while writing the best strategy parameters to 'best_strategy.json':")
                traceback.print_exc()

            # Write out a full trade list for the best strategy to best_strategy_trades.json
            if df_best is not None:
                # ADDED custom default function to handle pd.Timestamp
                def convert_timestamps_for_json(obj):
                    if isinstance(obj, pd.Timestamp):
                        return obj.isoformat()
                    return str(obj)

                try:
                    best_strategy_trades = generate_trade_list(df_best, best_strategy)
                    trades_records = best_strategy_trades.to_dict(orient='records')
                    # Pass our custom converter in 'json.dump'
                    with open('best_strategy_trades.json', 'w') as f:
                        json.dump(trades_records, f, indent=4, default=convert_timestamps_for_json)
                    print("\nAll trades for best strategy saved to 'best_strategy_trades.json'")
                except Exception as e:
                    print("An error occurred while writing best_strategy_trades.json:")
                    traceback.print_exc()

            print("\nAll strategy returns:")
            for strategy, t_ret in total_returns.items():
                print(f"{strategy}: {t_ret:.2f}%")
        else:
            print("\nNo strategies met the criteria.")

        if all_results_list:
            all_results = pd.concat(all_results_list, ignore_index=True)
            all_results.to_csv('optimization_results.csv', index=False)
            print("\nAll optimization results saved to 'optimization_results.csv'")
        else:
            print("\nNo optimization results to save.")
            all_results = pd.DataFrame()
    else:
        print("No strategies met the criteria. No comparison or results to display.")
        comparison_df = pd.DataFrame()
        all_results = pd.DataFrame()

    return all_results, comparison_df

--- END FILE: utils/analysis.py ---

--- BEGIN FILE: utils/helpers.py ---
# src/utils/helpers.py

import pandas as pd

def ensure_datetime_index(df):
    if 'datetime' not in df.columns:
        df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')
    if not isinstance(df.index, pd.DatetimeIndex):
        df.set_index('datetime', inplace=True)
    return df

def print_strategy_results(strategies):
    print("\nDetailed Strategy Results:")
    for name, result in strategies.items():
        print(f"{name}:")
        for key, value in result.items():
            print(f"{key}: {value}")
        print()

--- END FILE: utils/helpers.py ---


--------------

Thank you so very kindly for the kind attention.  I have an important request for this session.

Please adhere to these principles and repeat your response.

    1. Provide full and complete listings for any files that you advise me to change. 
    2. Keep all original content and comments unless explicitly requested to modify or delete them.
    3. Include the full file path as a comment at the top of each listing.
    4. Make minimal changes to ensure clarity and consistency.
    5. PLEASE Never remove existing functionality that had not been either requested to be removed, or stands in stark contrast of the work being requested.  When it must be removed make it very clear in the response that it was, and why it was removed.

Never speculate:

Please inspect the provided files to determine the exact logic and location for implementing the change. Please review the files for logic to modify and if you  cannot find the relevant logic, request the missing file.

Please provide full and complete listings for all the files that you are changing without placeholders. Please include all of the original logic and comments, unless the logic or comments need to be modified to reflect your new ehnhancements.

I cannot stress enough that you please retain my comments, in addition to the former logic except when they conflict with your changes.
You have frequently retained the Logic, but yet remove important comments and I ask you you take care to keep both the logic and comments
in tact. It can be very difficult when these items get removed.

Please explain your changes when they related to mistakes you have made.  
I like it when you are polite and admit your mistakes and then explain them.

------------

# Code Review Protocol

When modifying code, please:

1. Document:
   - Full file path as comment header on EVERY listing
   - Complete context and changes

2. Preserve:
   - ALL existing comments
   - ALL original features (unless explicitly requested to be changed)
   - File structure and formatting

3. Provide:
   - Complete file listings (no placeholders)
   - Only verified implementations
   - Request missing files if needed

4. Minimize:
   - Changes to existing code
   - Assumptions about implementation
   - Speculation about logic

5. Avoid sending identical files to previous ones sent down.
   - When some request I make is satisfied with a duplicate of the last version
   you gave me for some module and the copy you may wish to send me is identical
   to the last versions you gave me this is fine however unnecessary.  It is
   fine in such cases to just let me know there was no code changes to introduce
   to satisfy my last request.


Important: Never remove comments, documentation and especially not features
unless explicitly requested. Removing, changing or breaking existing features
is a common mistake you have made and it is the worst thing that can be done.
