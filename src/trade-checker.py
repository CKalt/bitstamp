#!/usr/bin/env python3
# src/trade-checker.py

"""
src/trade-checker.py

Verifies that the trades generated by src/tdr.py (either live or dry-run)
match valid signals from the strategy (MA or RSI) and do not exceed
limits or occur at suspicious prices/times.

Usage:
  python src/trade-checker.py --log_file=btcusd.log [--trades_file=non-live-trades.json] \
      [--best_strategy=best_strategy.json]

Logic Outline:
  1) Parse btcusd.log into a DataFrame with timestamps, prices, etc.
  2) Parse trades.json (or non-live-trades.json) to see the trades performed.
  3) Parse best_strategy.json to see which strategy (RSI or MA), parameters, signals, etc.
  4) Reconstruct or load signals from the log data to confirm valid times for trades.
  5) Check each trade for correctness:
     - Price within range at that time?
     - Signal time alignment?
     - Partial buys grouped as 1 daily trade?
  6) Print a final summary.
"""

import os
import sys
import argparse
import json
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

def parse_arguments():
    parser = argparse.ArgumentParser(description="Trade Checker for src/tdr.py")
    parser.add_argument('--log_file', type=str, default='btcusd.log',
                        help='Path to the btcusd.log file with raw trade data.')
    parser.add_argument('--trades_file', type=str, default='non-live-trades.json',
                        help='Path to the trades file (non-live-trades.json or trades.json).')
    parser.add_argument('--best_strategy', type=str, default='best_strategy.json',
                        help='Path to the best_strategy.json file.')
    parser.add_argument('--start_date', type=str, default='',
                        help='Start date for checking in YYYY-MM-DD format. Optional.')
    parser.add_argument('--end_date', type=str, default='',
                        help='End date for checking in YYYY-MM-DD format. Optional.')
    return parser.parse_args()

def parse_btcusd_log(log_file, start_date=None, end_date=None):
    """
    Similar logic to your parse_log_file from data.loader, but simplified here.
    """
    # Simplified approach: read entire log line by line
    data = []
    start_dt = None
    end_dt = None
    if start_date:
        start_dt = pd.to_datetime(start_date)
    if end_date:
        end_dt = pd.to_datetime(end_date)

    with open(log_file, 'r') as f:
        for line in f:
            try:
                rec = json.loads(line.strip())
                if rec.get('event') == 'trade':
                    d = rec['data']
                    ts = int(d['timestamp'])
                    dt = pd.to_datetime(ts, unit='s')
                    # date filter
                    if (start_dt and dt < start_dt) or (end_dt and dt > end_dt):
                        continue
                    data.append({
                        'timestamp': ts,
                        'datetime': dt,
                        'price': float(d['price']),
                        'amount': float(d['amount']),
                        'type': int(d['type']),
                    })
            except:
                pass  # ignore lines that fail

    df = pd.DataFrame(data)
    if not df.empty:
        df.sort_values('timestamp', inplace=True)
        df.reset_index(drop=True, inplace=True)
    return df

def parse_trades_file(trades_file):
    """
    Reads trades from either trades.json or non-live-trades.json
    """
    if not os.path.exists(trades_file):
        print(f"No trades file '{trades_file}' found. Returning empty.")
        return pd.DataFrame()

    with open(trades_file, 'r') as f:
        try:
            trades_data = json.load(f)
        except json.JSONDecodeError:
            print(f"Error parsing {trades_file}. Returning empty.")
            return pd.DataFrame()
    # trades_data is likely a list of dicts
    if not isinstance(trades_data, list):
        print(f"Unexpected structure in {trades_file}. Expecting list.")
        return pd.DataFrame()

    df_trades = pd.DataFrame(trades_data)
    # Convert timestamps
    if 'timestamp' in df_trades.columns:
        df_trades['timestamp'] = pd.to_datetime(df_trades['timestamp'])
    if 'signal_timestamp' in df_trades.columns:
        df_trades['signal_timestamp'] = pd.to_datetime(df_trades['signal_timestamp'])
    return df_trades

def reconstruct_signals(df, strategy_params):
    """
    Depending on 'Strategy' in best_strategy.json (MA or RSI),
    we can attempt to reconstruct signals from the log data df.

    df has columns ['timestamp', 'datetime', 'price', 'amount', 'type'].

    This function returns a DataFrame with an additional column
    that indicates the signal: 'MA_Signal' or 'RSI_Signal'
    """
    from indicators.technical_indicators import ensure_datetime_index
    from indicators.technical_indicators import (
        add_moving_averages, generate_ma_signals,
        calculate_rsi, generate_rsi_signals
    )

    if df.empty:
        return df

    # Convert to a resampled timeframe (e.g. 1H) for the strategy
    df2 = df.copy()
    df2 = ensure_datetime_index(df2)
    # For demonstration, do a 1H resample. You may want to detect from strategy_params
    df_resampled = df2.resample('1H').agg({
        'price': 'last',
        'amount': 'sum'
    }).dropna()

    df_resampled['timestamp'] = df_resampled.index

    if strategy_params.get('Strategy') == 'MA':
        short_w = int(strategy_params.get('Short_Window', 12))
        long_w = int(strategy_params.get('Long_Window', 36))
        df_resampled = add_moving_averages(df_resampled, short_w, long_w)
        df_resampled = generate_ma_signals(df_resampled)
        df_resampled['Signal'] = df_resampled['MA_Signal']
    elif strategy_params.get('Strategy') == 'RSI':
        rsi_w = int(strategy_params.get('RSI_Window', 14))
        ob = float(strategy_params.get('Overbought', 70))
        os_ = float(strategy_params.get('Oversold', 30))
        df_resampled = calculate_rsi(df_resampled, window=rsi_w, price_col='price')
        df_resampled = generate_rsi_signals(df_resampled, overbought=ob, oversold=os_)
        df_resampled['Signal'] = df_resampled['RSI_Signal']
    else:
        df_resampled['Signal'] = 0  # Not recognized

    df_resampled.dropna(subset=['Signal'], inplace=True)
    return df_resampled

def check_trades_against_signals(df_signals, df_trades, strategy_params):
    """
    Perform checks to ensure trades align with signals:
      - If a trade is 'buy', we want the last known signal in df_signals to be +1
      - If a trade is 'sell', we want the last known signal in df_signals to be -1
      - Check times & daily trade limit usage
      - Check partial trades

    Returns a list of warnings or issues found.
    """
    issues = []
    # daily limit from best_strategy
    max_trades_day = strategy_params.get('max_trades_per_day', 5)

    # Group partial buys
    # We'll see multiple "buy" trades in close time => partial buy
    # We can track them as one if they are close together
    # Or rely on the "reason" from the trade.
    # This can get more advanced if needed.

    # Convert df_signals index (datetimes) to an actual column
    if 'Signal' not in df_signals.columns:
        issues.append("No Signal column found in df_signals. Can't validate strategy signals.")
        return issues

    # For checking signals around trade time
    df_signals = df_signals.copy()
    df_signals.sort_index(inplace=True)

    df_trades = df_trades.copy()
    df_trades.sort_values('timestamp', inplace=True)

    # Track daily trades
    trade_count_daily = {}

    for i, row in df_trades.iterrows():
        # row['type'] is "buy" or "sell"
        trade_type = row.get('type')       # but in your logs, 'type' might be "buy"/"sell"
        # if you store it as row['type']=="buy", row['type']=="sell"
        # Some store row['type'] as an int, so adjust if needed.

        trade_type_str = row.get('type')
        # unify in case it's "buy" or "sell"
        if isinstance(trade_type_str, (int,float)):
            # you might have stored numeric type? If so, skip
            pass

        ts = row['timestamp']  # datetime
        trade_dt = pd.to_datetime(ts)

        # 1) check daily limit
        day_str = trade_dt.strftime('%Y-%m-%d')
        trade_count_daily.setdefault(day_str, 0)
        # If partial trades -> we must see if "reason" or "live_trading" or partial signature
        # For simplicity, just increment for each trade, or do detection for partial buys.
        # We'll assume partial buys have the same "timestamp" or close together.
        # This can be more advanced if needed.

        # 2) see if there's a matching signal near that time in df_signals
        # We'll look up the last row in df_signals before or at trade_dt
        df_signals_before = df_signals[df_signals.index <= trade_dt]
        if df_signals_before.empty:
            issues.append(f"Trade at {trade_dt} with no prior signals in df_signals.")
            continue

        last_signal = df_signals_before.iloc[-1]['Signal']
        if trade_type_str == "buy" and last_signal != 1:
            issues.append(f"Trade buy at {trade_dt} but last signal was {last_signal}, not +1.")
        elif trade_type_str == "sell" and last_signal != -1:
            issues.append(f"Trade sell at {trade_dt} but last signal was {last_signal}, not -1.")

        # We can also check price alignment:
        trade_price = float(row.get('price', 0))
        # Compare with df_signals_before.iloc[-1]['price'] or so
        # If you want to confirm the price is within plausible range
        # you'd do more advanced checks.

        # daily trade increment
        # If partial trade logic is used, you can detect partial trades by
        # checking if there's another buy with the same 'signal_timestamp'
        # or check the 'reason' field or 'theoretical_trade'.
        trade_count_daily[day_str] += 1

    # check if daily limit was exceeded
    for day, count in trade_count_daily.items():
        if count > max_trades_day:
            issues.append(f"Exceeded daily trade limit {max_trades_day} on {day} (had {count}).")

    return issues

def main():
    args = parse_arguments()

    # Load best_strategy
    if not os.path.exists(args.best_strategy):
        print(f"No best_strategy.json at {args.best_strategy}. Exiting.")
        sys.exit(1)
    with open(args.best_strategy, 'r') as f:
        try:
            best_strategy_params = json.load(f)
        except:
            print("Error reading best_strategy.json.")
            sys.exit(1)

    # Load btcusd.log
    df_prices = parse_btcusd_log(args.log_file, args.start_date, args.end_date)
    print(f"Loaded {len(df_prices)} records from {args.log_file}.")

    # Load trades
    df_trades = parse_trades_file(args.trades_file)
    print(f"Loaded {len(df_trades)} trades from {args.trades_file}.")

    # Reconstruct signals
    df_signals = reconstruct_signals(df_prices, best_strategy_params)
    print(f"Reconstructed signals. Found {df_signals['Signal'].abs().sum()} total +/- signals (approx).")

    # Validate
    issues = check_trades_against_signals(df_signals, df_trades, best_strategy_params)

    if issues:
        print("\n--- TRADE CHECKER REPORT ---")
        for issue in issues:
            print("ISSUE:", issue)
        print(f"\nFound {len(issues)} potential issues.")
    else:
        print("No issues found. All trades appear consistent with signals & limits.")

if __name__ == "__main__":
    main()
